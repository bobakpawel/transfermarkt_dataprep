from sqlalchemy import create_engine, MetaData, inspect, Table, select
import pandas as pd 
import numpy as np

pd.set_option('display.float_format', lambda x: '%.2f' % x)

server_name = 'XXX'
database_name = 'XXX'
connection_string = f'mssql+pyodbc://{server_name}/{database_name}?trusted_connection=yes&driver=ODBC+Driver+17+for+SQL+Server'

engine = create_engine(connection_string)
metadata = MetaData()

with engine.connect() as connection:
    inspector = inspect(engine)
    schema = inspector.get_schema_names()[-1]
    tables = inspector.get_table_names(schema = schema)

    leagues_tb = Table(tables[-5], metadata, autoload_with=engine, schema=schema)
    leagues_qr = select(leagues_tb)
    leagues_df = pd.read_sql(leagues_qr, engine)
    leagues_df['AVG_VALUE'] = leagues_df['LEAGUE_VALUE'] / leagues_df['NO_OF_PLAYERS']
    leagues_df['PLAYER_PER_TM'] = leagues_df['NO_OF_PLAYERS'] / leagues_df['NO_OF_CLUBS']

    clubs_tb = Table(tables[0], metadata, autoload_with=engine, schema=schema)
    clubs_qr = select(clubs_tb)
    clubs_df = pd.read_sql(clubs_qr, engine)
    
    clubs_det_tb = Table(tables[1], metadata, autoload_with=engine, schema=schema)
    clubs_det_qr = select(clubs_det_tb)
    clubs_det_df = pd.read_sql(clubs_det_qr, engine)
    
    games_team_tb = Table(tables[4], metadata, autoload_with=engine, schema=schema)
    games_team_qr = select(games_team_tb)
    games_team_df = pd.read_sql(games_team_qr, engine)
    
    games_date_tb = Table(tables[2], metadata, autoload_with=engine, schema=schema)
    games_date_qr = select(games_date_tb)
    games_date_df = pd.read_sql(games_date_qr, engine)
    
    players_bio_tb = Table(tables[7], metadata, autoload_with=engine, schema=schema)
    players_bio_qr = select(players_bio_tb)
    players_bio_df = pd.read_sql(players_bio_qr, engine)
    
    players_form_tb = Table(tables[8], metadata, autoload_with=engine, schema=schema)
    players_form_qr = select(players_form_tb)
    players_form_df = pd.read_sql(players_form_qr, engine)
    players_form_df['VALUE'] = players_form_df['VALUE'].replace(-1,0)
    
    ### REGARDING THE VALUE COLUMN, IT IS MORE REASONABLE TO FILL UNKNOWN VALUES WITH 0 RATHER THAN WITH -1, AS IT WAS DONE DURING THE SCRAPING PHASE.
    
    perf_tb = Table(tables[6], metadata, autoload_with=engine, schema=schema)
    perf_qr = select(perf_tb)
    perf_df = pd.read_sql(perf_qr, engine)
    
    games_res_tb = Table(tables[3], metadata, autoload_with=engine, schema=schema)
    games_res_qr = select(games_res_tb)
    games_res_df = pd.read_sql(games_res_qr, engine)
    
    players_ni_tb = Table(tables[-1], metadata, autoload_with=engine, schema=schema)
    players_ni_qr = select(players_ni_tb)
    players_ni_df = pd.read_sql(players_ni_qr, engine)

### DATA CLEANING AND CORRECTNESS VERIFICATION SECTION
### TABLES WERE VERIFIED FOR LOGICAL INCONSISTENCIES, AND ANY IDENTIFIED DATA MISCONCEPTIONS WERE REMOVED OR CORRECTED AFTER THE INVESTIGATION. CHECKING WAS DONE USING METHODS SUCH AS SORTING VALUES (IDENTIFYING OUTLIERS THAT WERE OBVIOUSLY TOO BIG OR TOO SMALL COMPARED TO OTHER VALUES), FILTERING (E.G., GAME DATE BEFORE THE SEASON OR FROM THE FUTURE WITH RESULTS), GROUPING BY, AND COUNTING VALUES REPETITIONS (TO IDENTIFY REPETITIVE IDS) AND MORE.

games_date_df.loc[~games_date_df['COUNTRY_ID'].isin(['SWE21', 'NOR23']),['GAME_YEAR','GAME_MONTH']].value_counts().sort_index() 
games_date_df.loc[(games_date_df['GAME_YEAR'] == 2023) & (games_date_df['GAME_MONTH'] == 1), 'GAME_MONTH'] = 9 ### A GAME PLAYED IN JANUARY 2023 WAS IDENTIFIED. SUCH A DATE IS ALMOST IMPOSSIBLE FOR THE 2023/2024 SEASON. AFTER MANUAL VERIFICATION, I FOUND THAT A GAME WITH THE SAME TEAMS, RESULT, GOALS, MINUTES OF GOALS, AND SCORERS, ETC., WAS PLAYED IN SEPTEMBER OF THAT YEAR. THEREFORE, THE MONTH OF THE GAME WAS UPDATED TO SEPTEMBER (9).

games_date_df[['GAME_YEAR', 'GAME_MONTH']].value_counts().sort_index() ### THERE ARE GAMES WITH THE YEAR 2024 AND THE MONTHS FROM JULY TO DECEMBER. THIS REQUIRES INVESTIGATION AND VERIFICATION TO TEST THE HYPOTHESIS THAT THESE ARE ONLY GAMES TO BE PLAYED IN NORWAY AND SWEDEN LATER IN THE SEASON OR IF THERE IS A CASE OF DATA COMPROMISE.
games_res_df[games_res_df['GAME_ID'].isin(games_date_df.loc[ ((games_date_df['COUNTRY_ID'].isin(['NOR23','SWE21'])) & (games_date_df['GAME_YEAR'] == 2023) ),'GAME_ID'])] ### THERE ARE 2ND ROUND SVENSKA CUPEN GAMES IN AUGUST 2023. THIS WOULD NOT BE STRANGE FOR ANY OTHER LEAGUE, BUT THE NEXT SWEDISH GAMES OF THAT SEASON WERE RECORDED IN FEBRUARY 2024. SAMPLE VERIFICATION OF THESE 8x GAMES IN GOOGLE SHOWS THAT THE GAME DATES ARE ACCURATE FOR THESE GAME IDS.
games_date_df.loc[~games_date_df['COUNTRY_ID'].isin(['NOR23','SWE21']), ['GAME_YEAR', 'GAME_MONTH']].value_counts().sort_index() ### THERE ARE GAMES TO BE PLAYED IN JULY 2024 AND LATER, BUT THESE GAMES ARE ONLY IN SWEDEN AND NORWAY, WHICH PLAY THEIR SEASONS IN A SPRING-AUTUMN SYSTEM. THE DATA IS CORRECT, BUT FUTURE GAMES WILL NOT BE ANALYZED; THEREFORE, THESE GAMES WILL SOON BE REMOVED.
games_date_df = games_date_df[ ~ ( ((games_date_df['GAME_YEAR'] == 2024) & (games_date_df['GAME_MONTH'] == 6) & (games_date_df['GAME_DOM'] >= 5)) | ((games_date_df['GAME_YEAR'] == 2024) & (games_date_df['GAME_MONTH'] >= 7)) ) ] ### 293x GAMES TO BE PLAYED IN THE FUTURE (20240605 AND LATER), IN NORWAY OR SWEDEN, WERE REMOVED FROM FURTHER ANALYSIS.
games_res_df = games_res_df[games_res_df['HOME_GOALS'] >= 0] ### GAMES TO BE PLAYED ON OR AFTER 2024-06-05 WERE ALSO REMOVED FROM games_res_df. THE CONDITION WAS TO KEEP GAMES WITH HOME_GOALS >= 0 (OR REMOVE HOME_GOALS == -1).
games_team_df = games_team_df[games_team_df['GOALS_SCORED'] >= 0] ### FUTURE GAMES WERE ALSO REMOVED FROM games_team_df USING THE SAME CONDITION (REMOVING GAMES WITH GOALS_SCORED LOWER THAN 0) TO IDENTIFY GAMES THAT HAVE NOT YET BEEN PLAYED.

games_team_df.loc[games_team_df['COMPETITION'] == 'NL','GAME_ID'].value_counts().reset_index().query(" count == 1 ") ### 15 'NL' GAMES FROM games_team_df ARE RECORDED FOR ONLY ONE OF THE TEAMS. DUE TO THE TABLE CREATION LOGIC, EVERY GAME_ID SHOULD BE REPORTED TWICE FOR THE NL COMPETITION IN EACH COUNTRY. THE ISSUE WAS CHECKED ON THE TRANSFERMARKT PAGE USING THE GAME CALENDARS FOR TEAMS WITH ISSUES (E.G., ITALIAN: ATALANTA, MILAN, FIORENTINA). THE PROBLEM ORIGINATES FROM THE ORIGINAL WEBPAGE, WHERE THESE GAMES ARE MISSING IN THESE TEAMS' SCHEDULES BUT ARE PRESENT IN THEIR RIVALS' CALENDARS.
games_team_df[games_team_df['GAME_ID'].isin(games_team_df.loc[games_team_df['COMPETITION'] == 'NL','GAME_ID'].value_counts().reset_index().query(" count == 1 ")['GAME_ID'])] ### TEAMS PRESENTED IN THE FILTERED DF AS OPPONENTS DO NOT HAVE THEIR OWN RECORD FOR THE RELEVANT GAME_ID RECORDED IN THEIR TEAM CALENDAR IN THE SCRAPED DATA FRAMES OR ON THE TRANSFERMARKT WEBPAGE.
games_res_df[ ( (games_res_df['HOME_TEAM_ID'] == 5) | (games_res_df['AWAY_TEAM_ID'] == 5) ) & (games_res_df['COMPETITION'] == 'NL') ].sort_values(by = 'MATCHDAY', key=lambda x: x.astype(int)) ### ONE OF THE TEAMS WITH AN INCOMPLETE CALENDAR (NOT EVERY GAME REPORTED IN games_team_df) IS AC MILAN (TEAM_ID = 5). CHECKING THE TABLE games_res_df SHOWED THAT THE TEAM HAS 38 LEAGUE GAMES RECORDED, WHICH IS THE CORRECT NUMBER OF ALL LEAGUE GAMES FOR A TEAM IN ITALY. AS OF NOW, IT APPEARS THAT games_res_df MIGHT BE A BETTER SOURCE TO COUNT THE ACTUAL NUMBER OF GAMES PLAYED BY TEAMS.

perf_df.loc[perf_df.groupby('TEAM_ID')['IN_TEAM'].idxmax(), ['TEAM_ID', 'TEAM', 'IN_TEAM']].merge(games_team_df.groupby(['TEAM_ID', 'TEAM'])['GAME_ID'].count().to_frame().reset_index(), on = ['TEAM_ID', 'TEAM']) ### THE CODE IDENTIFIES THE PLAYER (PLAYER_ID) WHO HAS BEEN IN THE MATCH SQUAD (IN_TEAM) MOST OFTEN FOR EACH TEAM (AND SAVES THAT NUMBER FOR EACH TEAM). THEN, THE CODE MERGES THE FIRSTLY CREATED DATAFRAME WITH games_team_df, WHICH IS EDITED TO COUNT THE NUMBER OF GAMES PLAYED BY EACH TEAM. THE MERGE IS DONE USING BOTH COLUMNS: TEAM_ID AND TEAM TO AVOID DUPLICATE TEAM NAMES ENTRIES. INTERESTINGLY, I NOTICED THERE IS NO MATCH FOR ONE OF THE TEAMS (THERE ARE 397 ROWS, NOT 398 ROWS).
perf_df.loc[perf_df.groupby('TEAM_ID')['IN_TEAM'].idxmax(), ['TEAM_ID', 'TEAM', 'IN_TEAM']].merge(games_team_df.groupby(['TEAM_ID', 'TEAM'])['GAME_ID'].count().to_frame().reset_index(), on = ['TEAM_ID', 'TEAM'], how = 'left').sort_values(by='GAME_ID') ### THE CODE FROM THE LINE ABOVE WAS REPEATED AND MERGED WITH THE PARAMETER how='left' TO IDENTIFY THE TEAM THAT WAS NOT MATCHING BEFORE: CERCLE BRUGGE WITH THE TEAM_ID: 520.
perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1] 
games_team_df.loc[games_team_df['TEAM_ID'] == 520,'TEAM'].head(1).to_frame().reset_index().iloc[0,1]  ### THE MISMATCH IN TEAM NAMES ARISES BECAUSE 'Cercle Brugge' IN games_team_df INCLUDES AN UNNECESSARY SPACE AFTER THE TEAM NAME: 'Cercle Brugge ', WHEREAS IN perf_df IT IS CORRECTLY WRITTEN AS 'Cercle Brugge'.
games_team_df.loc[games_team_df['TEAM_ID'] == 520,'TEAM'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1]
games_team_df.loc[games_team_df['OPPONENT_ID'] == 520,'OPPONENT'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1]
games_date_df.loc[games_date_df['HOME_TEAM_ID'] == 520,'HOME_TEAM'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1]
games_date_df.loc[games_date_df['AWAY_TEAM_ID'] == 520,'AWAY_TEAM'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1]
games_res_df.loc[games_res_df['HOME_TEAM_ID'] == 520,'HOME_TEAM'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1]
games_res_df.loc[games_res_df['AWAY_TEAM_ID'] == 520,'AWAY_TEAM'] = perf_df.loc[perf_df['TEAM_ID'] == 520, 'TEAM'].to_frame().reset_index().iloc[0,1] ### ALL OCCURRENCES OF TEAM_ID == 520 AS 'Cercle Brugge ' IN games_res_df, games_date_df, AND games_team_df, WHETHER AS HOME OR AWAY TEAM, ANALYZED TEAM, OR OPPONENT, WERE MANUALLY CHANGED TO 'Cercle Brugge' - THE CORRECT TEAM NAME FROM perf_df. THE TEAM NAME WAS ALSO VERIFIED IN SOURCES SUCH AS clubs_df, clubs_det_df, players_bio_df, players_form_df, AND players_ni_df, WHERE IT IS CORRECTLY PRONOUNCED WITHOUT AN UNNECESSARY SPACE AFTER THE TEAM NAME.

no_of_games_ver = perf_df.loc[perf_df.groupby('TEAM_ID')['IN_TEAM'].idxmax(), ['TEAM_ID', 'TEAM', 'IN_TEAM']].merge(games_team_df.groupby(['TEAM_ID', 'TEAM'])['GAME_ID'].count().to_frame().reset_index(), on = ['TEAM_ID', 'TEAM'])
no_of_games_ver['CHECK'] = no_of_games_ver.apply(lambda x : 1 if x['IN_TEAM'] <= x['GAME_ID'] else 0, axis = 1) ### FOR 57 TEAMS, THE PLAYER WHO WAS IN THE MATCH SQUAD MOST OFTEN HAS BEEN LISTED MORE TIMES THAN THE TEAM HAS PLAYED GAMES. THIS APPEARS TO BE AN ERROR THAT NEEDS TO BE DOUBLE-CHECKED, ESPECIALLY CONSIDERING KNOWN CASES OF LEAGUE GAMES NOT BEING RECORDED IN games_team_df FOR TEAMS SUCH AS AC MILAN, ATALANTA BC, OR PSV EINDHOVEN.

perf_df[perf_df['TEAM_ID'] == 279].sort_values('IN_TEAM', ascending = False).head(1) ### FOR FERENCVAROSI FC (HUNGARY, TEAM_ID == 279), THE PLAYER WHO WAS IN THE SQUAD MOST TIMES LAST SEASON WAS ADAM VARGA (342973). HE WAS RECORDED 55 TIMES IN THE "IN_TEAM" COLUMN ACCORDING TO THE DATABASE. THIS WAS ALSO MANUALLY VERIFIED AGAINST THE TRANSFERMARKT PAGE, WHICH SHOWED HIS APPEARANCES AS 33 TIMES IN LEAGUE GAMES, 6 TIMES IN THE MAGYAR KUPA, 8 TIMES IN THE CONFERENCE LEAGUE, 6 TIMES IN UEFA EUROPA CONFERENCE LEAGUE QUALIFICATION ROUNDS, AND 2 TIMES IN CHAMPIONS LEAGUE QUALIFICATION ROUNDS, SUMMING UP TO 55 APPEARANCES WITH THE TEAM LAST SEASON.
len(games_date_df[ (games_date_df['HOME_TEAM_ID'] == 279) | (games_date_df['AWAY_TEAM_ID'] == 279)]) == len(games_team_df[games_team_df['TEAM_ID'] == 279])  ### IN BOTH GAMES-RELATED DATAFRAMES, FERENCVAROSI FC (279) HAS RECORDED 52 GAMES, WHICH IS, OF COURSE, A LOWER NUMBER THAN THE 55 TEAM APPEARANCES OF ADAM VARGA (342973). IN PREVIOUS CASES (E.G., AC MILAN), THE PROBLEM WAS RELATED ONLY TO games_team_df, BUT HERE THE PROBLEM RELATES TO games_res_df and games_date_df AS WELL.
games_team_df[games_team_df['TEAM_ID'] == 279].groupby('COMPETITION')['GAME_ID'].count()  ### FERENCVAROSI FC (279) 52X GAMES LAST SEASON: 33X NL (THE SAME NUMBER AS ADAM VARGA), 2X EUROPEAN CHAMPIONS LEAGUE QUALIFICATION (SAME AS ADAM VARGA), 5X MAGYAR KUPA (LESS THAN ADAM VARGA'S 6), 12X ECo (LESS THAN ADAM VARGA'S 14).
games_team_df[ (games_team_df['TEAM_ID'] == 279) & (games_team_df['COMPETITION'] == 'Magyar Kupa')] ### LOOKING THROUGH FERENCVAROSI FC'S (279) 5X MAGYAR KUPA GAMES ARE VISIBLE, 1 GAME WAS NOT RECORDED (AS ADAM VARGA PLAYED 6 MAGYAR KUPA GAMES). COMPARED TO THE TRANSFERMARKT WEBPAGE, THERE IS NO SIGN OF THAT GAME IN FERENCVAROSI'S GAME CALENDAR, BUT AFTER EXAMINING ADAM VARGA'S CALENDAR, THE MISSING GAME WAS IDENTIFIED, IT IS THE 1ST ROUND GAME AGAINST NAGYECSED, WON BY FERENCVAROSI 0:8 ON NAGYECSED'S PITCH. (games_res_df ALSO MISSIES THAT GAME: games_res_df[ ((games_res_df['HOME_TEAM_ID'] == 279) | (games_res_df['AWAY_TEAM_ID'] == 279) ) & (games_res_df['COMPETITION'] != 'NL') ].sort_values('COMPETITION'))
games_team_df[ (games_team_df['TEAM_ID'] == 279) & (games_team_df['COMPETITION'] == 'ECo')] ### AFTER MANUALLY VERIFYING THE TRANSFERMARKT PAGE, FERENCVAROSI FC'S SCHEDULE IS MISSING THE 3RD ROUND EUROPEAN CUPS QUALIFICATION GAMES AGAINST HAMRUN SPARTANS. THESE GAMES CAN BE FOUND ONLINE ON TRANSFERMARKT BUT ONLY THROUGH ADAM VARGA'S APPEARANCES CALENDAR.

### AN ADDITIONAL EXAMPLE IS BORUSSIA DORTMUND (TEAM_ID == 16), WHERE THE PLAYER WHO WAS MOST OFTEN A TEAM MEMBER APPEARS MORE FREQUENTLY IN SQUAD THAN THE TEAM HAS PLAYED GAMES. MANUAL VERIFICATION REVEALED THAT BORUSSIA DORTMUND DOES NOT HAVE RECORDED A CHAMPIONS LEAGUE FINAL GAME. THIS GAME IS ORIGINALLY MISSING FROM THE BORUSSIA DORTMUND GAMES CALENDAR ON THE TRANSFERMARKT WEBPAGE (BUT APPEARS IN PLAYERS CALENDARS).
### A FEW MORE TEAMS WERE CHECKED LATER: FC BASEL 1893 (26) MISSES ONE SCHWEIZER CUP GAME (GAME IS PRESENT IN PLAYER'S CALENDAR BUT NOT IN TEAM'S SCHEDULE ON THE TRANSFERMARKT PAGE AND AS A RESULT, IT IS NOT PRESENT IN THE DATABASE TOO). ||| HNK RIJEKA (144) MISSES THE HRVATSKI CUP 2ND ROUND GAME AGAINST NK LIBERTAS AND 2 EUROPEAN CUP GAMES AGAINST KF DUKAGJINI. AGAIN, THE GAMES ARE NOT PRESENT IN THE DATABASE AS THEY ARE NOT LISTED IN THE TEAM'S CALENDAR ON THE TRANSFERMARKT PAGE (BUT CAN BE FOUND ON THE WEBPAGE THROUGH PLAYER CALENDARS). ||| ATHLETIC BILBAO (621) MISSES THE COPA DEL REY 1ST ROUND GAME AGAINST UE RUBI. THE REASON FOR THIS EXCLUSION IS THE SAME AS THE PREVIOUSLY OBSERVED LACK OF GAMES IN THE CASES OF OTHER ANALYZED CLUBS: THE GAME IS PRESENT IN PLAYER CALENDARS BUT, FOR UNKNOWN REASONS, IS NOT LISTED IN THE TEAM'S CALENDAR.
### THE VERIFICATION WAS LIMITED TO THE PREVIOUSLY MENTIONED TEAMS. HOWEVER, SUSPICIOUS DISCREPANCIES IN GAME COUNTS WERE OBSERVED ACROSS 57 TEAMS. SPECIFICALLY, FERENCVAROSI FC, FC BASEL 1893, HNK RIJEKA, AND ATHLETIC BILBAO ALL SHOWED MISSING GAMES, IDENTICAL IN ALL THREE GAME-RELATED DATASETS. THIS REVELATION IS IMPORTANT, AS IT INDICATES INACCURACIES IN THE SCRAPED DATABASE REGARDING TEAMS' GAME COUNTS. THE GAMES WERE FOUND IN PLAYER RECORDS BUT WERE NOT LISTED IN THE TEAM'S DEDICATED CALENDAR ON THE TRANSFERMARKT WEBSITE, A FACT VERIFIED MANUALLY. FUTURE PROJECTS INVOLVING TRANSFERMARKT SHOULD CONSIDER SCRAPING GAMES FROM ALTERNATIVE SOURCES ON TRANSFERMARKT PAGE.

games_team_df[ (games_team_df['COMPETITION'] == 'NL') & (games_team_df['TEAM_PLACE'] == -1) ].sort_values('COUNTRY_ID')  ### LEAGUE GAMES DATA SHOULD ALWAYS INCLUDE A LEAGUE PLACE, BUT THIS LACK OF TEAM PLACES OCCURRED PRIMARILY IN THE BULGARIAN DATA. TECHNICALLY, THIS COULD BE FIXED BY WRITING SPECIFIC CODE TO UPDATE THE DATABASE. HOWEVER, THERE IS NO NEED TO ADDRESS THIS AT THE CURRENT STAGE OF ANALYSIS, AS TEAM STANDINGS ARE NOT LIKELY TO BE THE FOCUS OF THE INVESTIGATION.
games_team_df[ (games_team_df['COMPETITION'] == 'NL') & (games_team_df['TEAM_PLACE'] != -1) ].sort_values('COUNTRY_ID').groupby(['COUNTRY_ID'])['TEAM_PLACE'].value_counts().to_frame().reset_index().sort_values(['COUNTRY_ID', 'TEAM_PLACE'])[0:50] ### TEAMS IN AUSTRIA ARE REPORTED IN POSITIONS RANGING FROM 1 TO 6 ONLY, WHICH IS INCORRECT. THIS HAPPENS BECAUSE AUSTRIAN TEAMS ARE SPLIT INTO CHAMPIONSHIP AND RELEGATION GROUPS DURING THE SEASON, INCORRECTLY AFFECTING CLUB POSITIONS BEFORE AND AFTER THE DIVISION. ANALYSIS BASED ON TEAM POSITIONS SHOULD BE POSTPONED UNTIL THE DATABASE IS UPDATED. SIMILAR PROBLEM, FOR SIMILAR REASONS OCURRED IN SWITZERLAND. IN COUNTRIES LIKE CZECH REPUBLIC, CROATIA, AND ENGLAND, EACH POSITION APPEARS CORRECTLY AND CONSISTENTLY WITH THE NUMBER OF MATCHDAYS. SOME LEAGUES SHOW VARYING NUMBERS OF OCCURRENCES PER POSITION, WHICH IS NOT NECESSARILY MISTAKE. SINCE TEAM POSITIONS WILL NOT BE ANALYZED, THIS ISSUE WAS NOT EXPLORED FURTHER.
games_team_df[ (games_team_df['COMPETITION'] != 'NL') & (games_team_df['TEAM_PLACE'] != -1)]  ### RECORDS WERE FOUND WHERE THE COMPETITION WAS NOT NL (LEAGUE GAMES), BUT TEAM_PLACE AND OPPONENT_PLACE HAD VALUES OTHER THAN -1. MANUAL VERIFICATION REVEALED THAT THESE 26 GAMES WERE PLAYOFFS FOR EUROPEAN CUP PLACEMENT OR TO AVOID RELEGATION. SINCE TEAM_PLACES WILL NOT BE ANALYZED, THESE VALUES WILL NOT BE UPDATED AT THIS TIME. THEREFORE, THERE IS NO NEED TO DECIDE WHETHER TO CHANGE THESE VALUES TO -1 OR KEEP THEM AS THEY ARE.

games_team_df[games_team_df['COACH'] != 'n/a'].groupby(['TEAM_ID', 'TEAM'])['COACH'].nunique().to_frame().sort_values(by='COACH') ### FC U CRAIOVA 1948 HAD 8 COACHES IN THE 2023/2024 SEASON (AFTER EXCLUDING ROWS WITH MISSING COACH INFORMATION). THIS INFORMATION IS CORRECT ACCORDING TO THE DATABASE AND IS ALSO CONFIRMED ON THE TRANSFERMARKT WEBPAGE. IT SHOULD BE HIGHLIGHTED THAT THE HIGH NUMBER OF COACHES FOR FC U CRAIOVA 1948 (AND A FEW OTHER TEAMS TOO) IS NOT ONLY DUE TO FREQUENT COACH CHANGES DURING THE SEASON BUT ALSO BECAUSE THE TEAM WAS RUN BY TEMPORARY TRAINERS BETWEEN THE RELEASE OF ONE COACH AND THE HIRING OF ANOTHER.

clubs_det_df.sort_values(by = 'FOREIGNERS_SH') ### ACCORDING TO clubs_det_df SORTED BY FOREIGNERS_SH COLUMN, AS MONACO (162) HAS 100% FOREIGNERS IN THEIR TEAM. IN clubs_df, THE TEAM SIZE AND NUMBER OF FOREIGNERS CAN BE VERIFIED. AS MONACO'S NUMBER OF FOREIGNERS (NO_OF_FOREIGNERS) IN clubs_df IS SMALLER THAN THE TOTAL NUMBER OF PLAYERS (NO_OF_PLAYERS) IN THE TEAM: 17 VS 24. THEREFORE, THE FOREIGNERS_SH VALUE FOR AS MONACO IN clubs_det_df IS INCORRECT.
clubs_df['FOR_SHARE'] = 100 * clubs_df['NO_OF_FOREIGNERS'] / clubs_df['NO_OF_PLAYERS'] ### A FOR_SHARE COLUMN WAS CREATED IN clubs_df TO MANUALLY COUNT THE SHARE OF FOREIGNERS IN EACH CLUB.
foreigners_share_ver = clubs_df[['TEAM_ID', 'TEAM', 'NO_OF_PLAYERS', 'NO_OF_FOREIGNERS', 'FOR_SHARE']].merge(clubs_det_df[['TEAM_ID', 'FOREIGNERS_SH']], on = 'TEAM_ID')
foreigners_share_ver['FOREIGNERS_SHARE_DIFF'] = foreigners_share_ver['FOR_SHARE'] - foreigners_share_ver['FOREIGNERS_SH']
foreigners_share_ver.sort_values('FOREIGNERS_SHARE_DIFF') ### clubs_df AND clubs_det_df WERE MERGED TO COMPARE THE SCRAPED VALUE OF FOREIGNERS_SH FROM clubs_det_df WITH THE CALCULATED VALUE OF FOR_SHARE FROM clubs_df. THE ONLY TEAM WITH A SIGNIFICANT DIFFERENCE BETWEEN THE TWO SOURCES IS AS MONACO (162). THEREFORE, THE FOREIGNERS_SH VALUE FOR AS MONACO IN clubs_det_df WAS UPDATED IN THE CODE LINE BELOW.
clubs_det_df.loc[clubs_det_df['FOREIGNERS_SH'] == 100, 'FOREIGNERS_SH'] = 100 * clubs_df.loc[clubs_df['TEAM_ID'] == 162, 'NO_OF_FOREIGNERS'] / clubs_df.loc[clubs_df['TEAM_ID'] == 162, 'NO_OF_PLAYERS']

perf_df['CHECK_1'] = perf_df.apply(lambda x : 1 if x['IN_TEAM'] < x['ON_PITCH'] else 0, axis = 1) ### A FLAG HAS BEEN CREATED TO IDENTIFY PLAYERS WHO HAVE A HIGHER VALUE IN THE ON_PITCH COLUMN THAN IN THE IN_TEAM COLUMN, HIGHLIGHTING A SITUATION THAT SHOULD NOT OCCUR LOGICALLY.
perf_df[perf_df['CHECK_1'] == 1] ### THERE ARE 4 PLAYERS WHO WERE RECORDED ON THE PITCH (ON_PITCH) MORE FREQUENTLY THAN IN THE TEAM (IN_TEAM). ACCORDING TO LOGIC, THE IN_TEAM VALUE SHOULD BE EQUAL TO OR GREATER THAN THE ON_PITCH VALUE. THIS ERROR WAS IDENTIFIED DURING DATABASE ANALYSIS AND APPLIES ONLY TO THESE 4 PLAYERS. DUE TO THE DIFFICULTY IN DETERMINING THE CORRECT VALUES THROUGH CALCULATIONS, NO UPDATES WILL BE MADE.
perf_df[(perf_df['TIME_PLAYED'] == 0) & (perf_df['ON_PITCH'] > 0)] ### PLAYERS WHO WERE ON THE PITCH AT LEAST ONCE (ON_PITCH) BUT RECORDED 0 MINUTES OF TIME PLAYED (TIME_PLAYED). THIS MAY HAVE OCCURRED WHEN THESE PLAYERS ENTERED THE PITCH IN THE LAST SECONDS OF THE GAME, YET THERE IS NO HARD EVIDENCE TO SUPPORT THIS THEORY. NO UPDATES WILL BE MADE, AS DETERMINING AN ALTERNATIVE VALUE FOR THE 110 IDENTIFIED PLAYERS WOULD REQUIRE MANUAL VERIFICATION.
perf_df[(perf_df['TIME_PLAYED'] == 0) & ( (perf_df['GOALS'] > 0) | (perf_df['ASSISTS'] > 0) | (perf_df['YELLOW_CARDS'] > 0 ) | (perf_df['DOUBLE_YELLOW_CARDS'] > 0) | perf_df['RED_CARDS'] > 0)]  ### 2 PLAYERS WHO PLAYED 0 MINUTES (TIME_PLAYED) BUT ACHIEVED ONE OF THE TARGETS: SCORED A GOAL, PROVIDED AN ASSIST, OR RECEIVED A CARD FROM THE REFEREE. THESE PLAYERS WERE IDENTIFIED BECAUSE ONE RECEIVED A YELLOW CARD AND THE OTHER RECEIVED A RED CARD. TECHNICALLY, IT IS POSSIBLE TO RECEIVE A CARD WHILE BEING ON THE BENCH.
players_form_df.loc[ (players_form_df['CONTRACT_EXPIRY_YEAR'] < 2024) & (players_form_df['CONTRACT_EXPIRY_YEAR'] > -1),['CONTRACT_EXPIRY_YEAR', 'CONTRACT_EXPIRY_MONTH']] = [-1,-1] ### A PLAYER (ID: 465568) WHOSE CONTRACT WAS LISTED AS ENDING IN 2005 WAS IDENTIFIED AS AN OBVIOUS MISTAKE IN 2024. AFTER MANUAL VERIFICATION, THE VALUE FROM THE TRANSFERMARKT PAGE WAS CORRECTLY SCRAPED. AS A RESULT, THE VALUES IN THE CONTRACT_EXPIRY_YEAR AND CONTRACT_EXPIRY_MONTH COLUMNS WERE MANUALLY CHANGED TO -1 (UNKNOWN VALUE).

not_in_and_perf_df_check = perf_df.loc[perf_df['CURRENT_FLG'] == -1, ['PLAYER_ID', 'NAME', 'TEAM_ID', 'TEAM', 'ON_PITCH', 'TIME_PLAYED']].merge(players_ni_df[['PLAYER_ID', 'NAME', 'POTENTIAL_TEAM_ID', 'POTENTIAL_TEAM', 'ON_PITCH', 'TIME_PLAYED']], left_on = ['PLAYER_ID', 'TEAM_ID'], right_on = ['PLAYER_ID', 'POTENTIAL_TEAM_ID'])  ### DF perf_df WAS FILTERED TO INCLUDE ONLY PLAYERS WHO ARE NOT CURRENTLY ASSIGNED TO THE SQUAD OF ANY ANALYZED TEAMS (NOT PRESENT IN TEAM SQUADS ON THE TRANSFERMARKT PAGE AND THEREFORE NOT PRESENT IN DFs: players_bio_df AND players_form_df). THIS SITUATION IS POSSIBLE DUE TO PLAYERS BEING SOLD TO LOWER LEAGUES IN THE ANALYZED COUNTRIES, TEAMS BEING PRESENT IN COUNTRIES THAT WERE NOT ANALYZED, OR PLAYERS BEING MEMBERS OF YOUTH TEAMS, AMONG OTHER REASONS. THE FIRST VERIFIED FACT IS THAT THERE ARE 3061 PLAYERS IN perf_df WITH CURRENT_FLG == -1, WHICH IS THE SAME NUMBER OF ROWS AS IN players_ni_df. AFTER MERGING THESE TWO SOURCES, THERE ARE STILL 3061 ROWS IN THE FINAL DF.
not_in_and_perf_df_check['NAME_CHECK'] = not_in_and_perf_df_check.apply(lambda x : 1 if x['NAME_x'] == x['NAME_y'] else 0, axis = 1)
not_in_and_perf_df_check['ON_PITCH_CHECK'] = not_in_and_perf_df_check.apply(lambda x : 1 if x['ON_PITCH_x'] == x['ON_PITCH_y'] else 0, axis = 1)
not_in_and_perf_df_check['TP_CHECK'] = not_in_and_perf_df_check.apply(lambda x : 1 if x['TIME_PLAYED_x'] == x['TIME_PLAYED_y'] else 0, axis = 1) ### THREE FLAG COLUMNS WERE CREATED TO COMPARE PLAYER NAMES, TIMES THEY WERE PRESENT ON THE PITCH, AND NUMBER OF MINUTES PLAYED BY PLAYERS. BASED ON THE FILTERING BELOW, THERE ARE NO DIFFERENCES BETWEEN THESE TWO SOURCES.
not_in_and_perf_df_check[ (not_in_and_perf_df_check['NAME_CHECK'] != 1) | (not_in_and_perf_df_check['ON_PITCH_CHECK'] != 1) | (not_in_and_perf_df_check['TP_CHECK'] != 1) ] 

players_ni_df[players_ni_df['OVERAL_POSITION'].isna()] ### 79 PLAYERS FROM players_ni_df DO NOT HAVE OVERAL_POSITION ASSIGNED. THE REASON FOR THIS IS THAT THE DICTIONARY USED DURING THE SCRAPING PHASE DID NOT INCLUDE ACCURATE VALUES FOR 'Midfield' AND 'Attack'. THE FOLLOWING CODE REPAIRS THIS IDENTIFIED ISSUE.
players_ni_df.loc[players_ni_df['POSITION'] == 'Midfield', 'OVERAL_POSITION'] = 'MID'
players_ni_df.loc[players_ni_df['POSITION'] == 'Attack', 'OVERAL_POSITION'] = 'FOR'

columns_to_merge_perf_df = ['COUNTRY_ID', 'TEAM_ID', 'TEAM', 'PLAYER_ID', 'CURRENT_FLG']
columns_to_merge_leagues_df = ['COUNTRY_ID', 'COUNTRY', 'NO_OF_PLAYERS', 'AVG_AGE', 'FOREIGNERS_SH', 'LEAGUE_VALUE']
columns_to_merge_players_bio_df = ['PLAYER_ID', 'AGE', 'HEIGHT']
columns_to_merge_players_form_df = ['PLAYER_ID', 'JOINED_YEAR', 'CONTRACT_EXPIRY_YEAR', 'VALUE'] 

perf_leagues_df = perf_df.loc[perf_df['CURRENT_FLG'] == 1, columns_to_merge_perf_df].merge(leagues_df[columns_to_merge_leagues_df], on = 'COUNTRY_ID')
perf_leagues_bio_df = perf_leagues_df.merge(players_bio_df[columns_to_merge_players_bio_df], on = 'PLAYER_ID', how = 'inner')
plbf_df = perf_leagues_bio_df.merge(players_form_df[columns_to_merge_players_form_df], on = 'PLAYER_ID', how = 'inner')

plbf_df_verify = plbf_df.groupby('COUNTRY_ID').agg({'LEAGUE_VALUE' : 'min', 'VALUE' : 'sum', 'NO_OF_PLAYERS' : 'min', 'PLAYER_ID' : 'count', 'AVG_AGE' : 'min', 'AGE' : 'mean'}).reset_index()
plbf_df_verify['VALUE_CHECK'] = plbf_df_verify['LEAGUE_VALUE'] - plbf_df_verify['VALUE']
plbf_df_verify['NO_OF_PLAYERS_CHECK'] = plbf_df_verify['NO_OF_PLAYERS'] - plbf_df_verify['PLAYER_ID']
plbf_df_verify['AVG_AGE_CHECK'] = plbf_df_verify['AVG_AGE'] - plbf_df_verify['AGE']   

### DURING THE VERIFICATION, I COMPARED VALUES FOR LEAGUES: CALCULATED AVG_AGE AND LEAGUE_VALUE, AS WELL AS THE NUMBER OF PLAYERS, DERIVED FROM SCRAPED TABLES, WITH THOSE SCRAPED FROM TRANSFERMARKT AND STORED IN THE leagues_df TABLE.
### THE RESULTS ARE AS FOLLOWS: THE NUMBER OF PLAYERS IS ALMOST EXACTLY THE SAME, WHILE AVG_AGE VARIES BY + 0.44 TO 0.56. THAT DIFFERENCE MIGHT BE EXPLAINED WITH THE HYPOTHESIS THAT THE AVG_AGE VALUE IN THE LEAGUE TABLE WAS COUNTED BEFORE THE SEASON STARTED (OR AT SOME POINT OF THE SEASON). THE DIFFERENCE OF ~0.5 FOR EVERY SINGLE LEAGUE SUPPORTS THAT ASSUMPTION.
### AS FOR LEAGUE_VALUE, THE DIFFERENCES PER LEAGUE ARE IN THE RANGE OF -3.7 TO +5.2. THIS REPRESENTS THE SUM OF OVERALL PLAYERS' VALUE PER LEAGUE. ON THE LEVEL OF AVG PLAYER VALUE PER LEAGUE, THE DIFFERENCES ARE IN THE RANGE OF -0.01 TO 0.01, WHICH IS MINIMAL.
### DUE TO THAT FACT, AS THE DIFFERENCES ARE MINIMAL, VALUES FROM THE leagues_df TABLE OR CALCULATED VALUES GROUPED FROM OTHER TABLES MIGHT BE USED FOR FURTHER ANALYSIS.

plbf_df_columns_further_analysis = ['COUNTRY_ID', 'COUNTRY', 'TEAM_ID', 'PLAYER_ID', 'NO_OF_PLAYERS', 'AVG_AGE', 'FOREIGNERS_SH', 'LEAGUE_VALUE', 'HEIGHT', 'JOINED_YEAR', 'CONTRACT_EXPIRY_YEAR']

plbf_df_copy = plbf_df[plbf_df_columns_further_analysis].copy()
plbf_df_copy['HEIGHT'] = plbf_df_copy['HEIGHT'].replace(-1, np.NaN)
plbf_df_copy['HEIGHT'].fillna(plbf_df_copy.groupby('TEAM_ID')['HEIGHT'].transform('mean'), inplace = True)
plbf_df_copy['JOINED_YEAR'] = plbf_df_copy['JOINED_YEAR'].replace(-1, np.NaN)
plbf_df_copy['JOINED_YEAR'].fillna(plbf_df_copy.groupby('TEAM_ID')['JOINED_YEAR'].transform('mean'), inplace = True)
plbf_df_copy['JOINED_YEAR'] = plbf_df_copy['JOINED_YEAR'].astype(float)
plbf_df_copy['CONTRACT_EXPIRY_YEAR'] = plbf_df_copy['CONTRACT_EXPIRY_YEAR'].replace(-1, np.NaN)
plbf_df_copy['CONTRACT_EXPIRY_YEAR'].fillna(plbf_df_copy.groupby('TEAM_ID')['CONTRACT_EXPIRY_YEAR'].transform('mean'), inplace = True)
plbf_df_copy['CONTRACT_EXPIRY_YEAR'] = plbf_df_copy['CONTRACT_EXPIRY_YEAR'].astype(float)

### ON THE SINGLE PLAYER LEVEL, SOME DATA IS MISSING, E.G., ONE PLAYER DOES NOT HAVE INFORMATION ABOUT HIS HEIGHT (FILLED WITH -1), BUT DOES HAVE PRECISE INFORMATION ABOUT HIS CONTRACT EXPIRY YEAR AND/OR OTHER METRICS.
### TO AVOID EXCLUDING TOO MANY ROWS FROM FURTHER ANALYSIS AND TO PREVENT FURTHER SCORES FROM BEING CORRUPTED BY -1 VALUES, THE -1 VALUE FOR THESE THREE COLUMNS WAS REPLACED WITH THE AVERAGE VALUE OF THE METRIC FOR THE EXACT TEAM THE PLAYER PLAYS FOR.

plbf_df_grouped = plbf_df_copy.groupby(['COUNTRY_ID', 'COUNTRY']).agg({'NO_OF_PLAYERS' : 'min', 'AVG_AGE' : 'min', 'FOREIGNERS_SH' : 'min', 'LEAGUE_VALUE' : 'min',
                                                                       'HEIGHT' : 'mean', 'JOINED_YEAR' : 'mean', 'CONTRACT_EXPIRY_YEAR' : 'mean'}).reset_index().sort_values(by = 'LEAGUE_VALUE', ascending = False)
plbf_df_grouped['AVG_VALUE'] = plbf_df_grouped['LEAGUE_VALUE'] / plbf_df_grouped['NO_OF_PLAYERS']
plbf_df_grouped['EXPERIENCE'] = 2024.5 - plbf_df_grouped['JOINED_YEAR'] ### A COLUMN WAS ADDED TO CALCULATE THE AVERAGE TIME AN AVERAGE PLAYER PLAYS FOR HIS CURRENT TEAM IN EACH COUNTRY.
plbf_df_grouped['CONTRACT_LENGTH'] = plbf_df_grouped['CONTRACT_EXPIRY_YEAR'] - 2024.5 ### A COLUMN WAS ADDED TO CALCULATE HOW MANY MORE YEARS OR MONTHS THE AVERAGE PLAYER'S CONTRACT IS VALID IN EACH COUNTRY.

perf_ctr_df = perf_df.merge(leagues_df[['COUNTRY_ID', 'COUNTRY']], on = 'COUNTRY_ID')
perf_ctr_df['PLAYED_FLG'] = np.where(perf_ctr_df['ON_PITCH'] > 0, 1, 0)     ### A FLAG WAS CREATED TO INDICATE IF A PLAYER HAS PLAYED AT LEAST ONE MINUTE DURING THE GAMES (APPEARED ON THE PITCH AT LEAST ONCE). THE UNDERLYING ASSUMPTION IS THAT THE VALUE IN THE ON_PITCH COLUMN IS A BETTER INDICATOR THAN THE NUMBER OF MINUTES RECORDED IN THE TIME_PLAYED COLUMN. DURING THE DATA VERIFICATION, 110 PLAYERS WERE FOUND WHO WERE MARKED AS HAVING APPEARED ON THE PITCH AT LEAST ONCE (ON_PITCH > 0) BUT RECORDED 0 MINUTES PLAYED (TIME_PLAYED == 0). THERE WERE 0 PLAYERS WITH ON_PITCH VALUE EQUAL TO 0 AND TIME_PLAYED BIGGER THAN 0.
perf_ctr_df['SCORED_FLG'] = np.where(perf_ctr_df['GOALS'] > 0, 1, 0)        ### CREATION OF THE FLAG THAT INDICATES IF A PLAYER HAS SCORED AT LEAST ONE GOAL DURING THE GAMES.
perf_ctr_df['TIME_PLAYED_SH'] = perf_ctr_df['TIME_PLAYED'] / perf_ctr_df.groupby('TEAM_ID')['TIME_PLAYED'].transform('max')  ### THE RATIO WAS CALCULATED BY DIVIDING THE TIME PLAYED BY THE PLAYER BY THE MAXIMUM TIME PLAYED BY A PLAYER FROM THE SAME TEAM. 
perf_ctr_df['TIME_PLAYED_10_PCT_FLG'] = np.where(perf_ctr_df['TIME_PLAYED_SH'] >= 0.1, 1, 0) ### A FLAG WAS CREATED TO INDICATE IF A PLAYER HAS PLAYED AT LEAST 10% OF THE TIME PLAYED BY THE TEAMMATE WITH THE HIGHEST NUMBER OF MINUTES ON THE PITCH.
perf_ctr_df.loc[perf_ctr_df['CURRENT_FLG'] == -1,'CURRENT_FLG'] = pd.NA
perf_ctr_df.loc[perf_ctr_df['PTS_PER_GAME'] < 0, 'PTS_PER_GAME'] = pd.NA ### IT WAS NOTICED THAT TWO PLAYERS HAVE RECORDED AN AVERAGE OF -1 POINT PER GAME. SUCH A STATISTIC IS IMPOSSIBLE AS THERE ARE NO NEGATIVE POINTS IN FOOTBALL. DUE TO THIS, THESE VALUES WERE MANUALLY CHANGED TO pd.NA TO EXCLUDE THEIR INFLUENCE ON FUTURE STATISTICAL CALCULATIONS.

perf_ctr_grouped = perf_ctr_df.groupby(['COUNTRY_ID', 'COUNTRY']).agg({'TEAM_ID' : 'nunique', 'PLAYER_ID' : 'count', 'PLAYED_FLG' : 'sum', 'CURRENT_FLG' : 'sum', 'GOALS' : 'sum', 'SCORED_FLG' : 'sum', 'ASSISTS' : 'sum', 'YELLOW_CARDS' : 'sum', 'RED_CARDS' : 'sum', 'TIME_PLAYED' : 'sum', 'TIME_PLAYED_10_PCT_FLG' : 'sum'}).reset_index()
perf_ctr_grouped.columns = ['COUNTRY_ID', 'COUNTRY', 'TEAMS', 'PROT_PLRS', 'PLAYED_PLRS', 'CURRENT_FLG_PLRS', 'GOALS', 'SCORERS', 'ASSISTS', 'YELLOW_CARDS', 'RED_CARDS', 'TIME_PLAYED', '>10_PCT_TP_PLRS']
perf_ctr_grouped['CURRENT_FLG_PLRS'] = perf_ctr_grouped['CURRENT_FLG_PLRS'].astype(int)
perf_ctr_grouped = perf_ctr_grouped[~perf_ctr_grouped['COUNTRY_ID'].isin(['NOR23','SWE21'])].reset_index(drop = True)  ### NORWAY AND SWEDEN ARE EXCEPTIONS AS THESE COUNTRIES START THEIR SEASONS IN SPRING. AT THE TIME THE DATA WAS GATHERED (JUNE 2024), THE SWEDISH LEAGUE HAD PLAYED ONLY 12 ROUNDS AND THE NORWEGIAN LEAGUE HAD PLAYED ONLY 11 ROUNDS. LESS THAN HALF OF THE PLANNED GAMES WERE PLAYED SO FAR IN THESE LEAGUES, WHICH MAY NEGATIVELY AFFECT THE RESEARCH RESULTS. THEREFORE, THESE TWO COUNTRIES WERE REMOVED FROM FURTHER ANALYSIS.
perf_ctr_grouped['MNS_PLD_M'] = perf_ctr_grouped['TIME_PLAYED'] / perf_ctr_grouped['PLAYED_PLRS'] ### THE CALCULATION OF THE AVERAGE NUMBER OF MINUTES PLAYED BY A SINGLE PLAYER (WHO APPEARED ON THE PITCH AT LEAST ONCE) IN EACH COUNTRY.
perf_ctr_grouped['ONLY_BENCH_SH'] = ((perf_ctr_grouped['PROT_PLRS'] - perf_ctr_grouped['PLAYED_PLRS']) / perf_ctr_grouped['PROT_PLRS']) * 100 ### RATIO CALCULATION OF PLAYERS WHO ONLY SAT ON THE BENCH BUT NEVER ENTERED THE PITCH DURING THE 2023/2024 SEASON.
perf_ctr_grouped['PLRS_PER_TEAM'] = perf_ctr_grouped['PLAYED_PLRS'] / perf_ctr_grouped['TEAMS'] ### THE AVERAGE NUMBER OF PLAYERS WHO PLAYED IN THE TEAM IN EACH OF THE COUNTRIES. IN OTHER WORDS, HOW MANY PLAYERS PLAYED FOR ONE TEAM ON AVERAGE DURING THE LAST SEASON.
perf_ctr_grouped['>10_PCT_PLRS_PER_TEAM'] = perf_ctr_grouped['>10_PCT_TP_PLRS'] / perf_ctr_grouped['TEAMS'] 

all_games = {}
league_games = {}
for country in perf_ctr_grouped['COUNTRY_ID'].to_list():
    home = games_res_df[(games_res_df['HOME_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country]['TEAM_ID'].to_list())) & (games_res_df['HOME_GOALS'] > -1)]
    away = games_res_df[(games_res_df['AWAY_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country]['TEAM_ID'].to_list())) & (games_res_df['HOME_GOALS'] > -1)]
    all_games_df = pd.concat(objs = [home,away])
    league_games_df = games_res_df[(games_res_df['HOME_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country]['TEAM_ID'].to_list())) & (games_res_df['HOME_GOALS'] > -1) & (games_res_df['COMPETITION'] == 'NL')]
    all_games[country] = len(all_games_df)
    league_games[country] = len(league_games_df)
games_in_countries_df = pd.DataFrame(list(all_games.items()), columns=['COUNTRY_ID', 'ALL_GAMES']).merge(pd.DataFrame(list(league_games.items()), columns=['COUNTRY_ID', 'LEAGUE_GAMES']), on = 'COUNTRY_ID')

### THE FOR LOOP ITERATES THROUGH EACH OF THE 23 ANALYZED COUNTRIES (BY COUNTRY_ID, EXCEPT EXCLUDED NORWAY AND SWEDEN). THE DATAFRAME USED FOR THE NUMBER OF GAMES CALCULATION IS games_res_df, WHICH IS A BETTER SOURCE THAN games_team_df, ALTHOUGH NOT A PERFECT ONE TOO, AS SHOWN DURING THE DATABASE CLEANING AND VERIFICATION PHASE.
### DURING EACH ITERATION, THREE DATAFRAMES ARE CREATED: ONE INCLUDES TEAMS FROM THE HIGHEST LEAGUE OF THE ITERATED COUNTRY THAT WERE THE HOME TEAM, THE SECOND INCLUDES TEAMS FROM THE HIGHEST LEAGUE OF THE COUNTRY THAT WERE THE AWAY TEAM, AND THE THIRD FOCUSES ONLY ON NON-DUPLICATED LEAGUE GAMES. OVERALL, GAMES FROM THE NATIONAL LEAGUE, CUP, AND EUROPEAN CUPS ARE CONSIDERED FOR THESE THREE DATAFRAMES.
### TWO DATAFRAMES CONSISTING OF ALL HOME AND AWAY GAMES ARE THEN CONCATENATED, AND ONE DATAFRAME THAT KEEPS DUPLICATED ROWS (GAME_ID) IS CREATED. THIS SOURCE WILL BE USED TO CALCULATE THE AVERAGE NUMBER OF GAMES IN ALL AREAS (NATIONAL CUP, LEAGUE, EURO CUPS, ETC.) PER TEAM IN THE COUNTRY. THE SECOND DATAFRAME HOLDS NON-DUPLICATED GAME_IDs FOR LEAGUE GAMES, WHICH WILL BE USED FOR LEAGUE-ONLY CALCULATIONS.
### THE LENGTH OF EACH DATAFRAME (NUMBER OF ROWS) REPRESENTS THE NUMBER OF GAMES PLAYED BY TEAMS FROM THAT COUNTRY. IT SHOULD BE HIGHLIGHTED THAT DURING VERIFICATION, IT WAS PROVEN THAT THE TRANSFERMARKT PAGE DOES NOT RECORD EVERY SINGLE GAME FOR EACH TEAM (WHEN THE TEAM'S GAME CALENDAR IS THE SCRAPING SOURCE). THEREFORE, THE NUMBER OF GAMES AND GOALS IN LEAGUE STATISTICS IS CLOSE TO BUT NOT 100% ACCURATE.

games_in_countries_from_perf_df = perf_df.groupby(['COUNTRY_ID', 'TEAM_ID', 'TEAM'])['IN_TEAM'].max().reset_index().groupby('COUNTRY_ID')['IN_TEAM'].sum().reset_index()
games_in_countries_verify = games_in_countries_df.merge(games_in_countries_from_perf_df, on = 'COUNTRY_ID')
games_in_countries_verify['CHECK'] = games_in_countries_verify['ALL_GAMES'] - games_in_countries_verify['IN_TEAM']
games_in_countries_verify['FINAL_GAMES_NO'] = games_in_countries_verify.apply(lambda x : x['ALL_GAMES'] if x['ALL_GAMES'] >= x['IN_TEAM'] else x['IN_TEAM'], axis = 1)

### A VERIFICATION OF THE NUMBER OF GAMES PLAYED BY TEAMS IN EACH COUNTRY WAS CONDUCTED BASED ON PLAYER PERFORMANCE STATISTICS IN perf_df. THE TOTAL GAMES FOR EACH COUNTRY REPRESENTS THE SUM OF APPEARANCES BY THE PLAYERS WHO MOST FREQUENTLY PARTICIPATED IN THE SQUAD OF EACH TEAMS. IT SHOULD BE NOTED THAT THERE IS NO GUARANTEE THAT ANY PLAYER WILL ALWAYS BE A TEAM MEMBER, HENCE SUCH STATISTICS ARE IMPERFECT. HOWEVER, FOR COUNTRIES LIKE SPAIN OR HUNGARY, MORE GAMES WERE COUNTED USING THIS METHOD FROM perf_df THAN FROM PREVIOUSLY PRESENTED CALCULATIONS CONDUCTED WITH DATA FROM games_res_df.
### THE ANALYST DECIDED TO USE THE HIGHER NUMBER OF GAMES PER COUNTRY FROM ONE OF THE TWO CREATED DATA SOURCES FOR FURTHER ANALYSIS. THE DATAFRAMES WERE MERGED, AND A COLUMN FINAL_GAMES_NO WAS CREATED TO RETAIN THE HIGHER NUMBER OF GAMES FROM BOTH SOURCES. THE LEAGUE GAMES NUMBER METRIC WAS ALSO KEPT TO BE USED IN LEAGUE GAMES ANALYTICS AND STATISTICS.

perf_ctr_grouped_plus = perf_ctr_grouped.merge(games_in_countries_verify[['COUNTRY_ID', 'FINAL_GAMES_NO', 'LEAGUE_GAMES']], on = 'COUNTRY_ID', how = 'inner')

def goals_scored_verify(country_id, df):
    nl_home_goals = df[(df['COUNTRY_ID'] == country_id) & (df['COMPETITION'] == 'NL') & (df['HOME_GOALS'] > -1)]['HOME_GOALS'].sum()
    nl_away_goals = df[(df['COUNTRY_ID'] == country_id) & (df['COMPETITION'] == 'NL') & (df['HOME_GOALS'] > -1)]['AWAY_GOALS'].sum()
    cup_home_goals = df[(df['COUNTRY_ID'] == country_id) & (df['COMPETITION'] != 'NL') & (df['HOME_GOALS'] > -1) & (df['>90_FLG'] == 0) & df['HOME_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country_id]['TEAM_ID'].to_list())]['HOME_GOALS'].sum()
    cup_away_goals = df[(df['COUNTRY_ID'] == country_id) & (df['COMPETITION'] != 'NL') & (df['AWAY_GOALS'] > -1) & (df['>90_FLG'] == 0) & df['AWAY_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country_id]['TEAM_ID'].to_list())]['AWAY_GOALS'].sum()
    uefa_home_goals = df[(df['COUNTRY_ID'] == 'UEFA') & (df['HOME_GOALS'] > -1) & (df['>90_FLG'] == 0) & df['HOME_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country_id]['TEAM_ID'].to_list())]['HOME_GOALS'].sum()
    uefa_away_goals = df[(df['COUNTRY_ID'] == 'UEFA') & (df['HOME_GOALS'] > -1) & (df['>90_FLG'] == 0) & df['AWAY_TEAM_ID'].isin(clubs_df[clubs_df['COUNTRY_ID'] == country_id]['TEAM_ID'].to_list())]['AWAY_GOALS'].sum()
    
    goals_sum = nl_home_goals + nl_away_goals + cup_home_goals + cup_away_goals + uefa_home_goals + uefa_away_goals
    source_2 = perf_ctr_grouped.loc[perf_ctr_grouped['COUNTRY_ID'] == country_id, 'GOALS'].sum()
    league_goals = nl_home_goals + nl_away_goals 
    
    return [source_2, goals_sum, source_2 - goals_sum, (100 * (source_2 - goals_sum) / source_2).round(2), (100 * (source_2 - goals_sum) / goals_sum).round(2), league_goals]

goals_scored_verify('FRA05', games_res_df)
perf_ctr_grouped_plus['LEAGUE_GOALS'] = 0 ### CREATING A NEW COLUMN WITH A DEFAULT VALUE OF 0, WHICH WILL BE POPULATED WITH REAL VALUES IN SUBSEQUENT LINES OF CODE.

for country in perf_ctr_grouped_plus['COUNTRY_ID'].to_list():
    perf_ctr_grouped_plus.loc[perf_ctr_grouped_plus['COUNTRY_ID'] == country, 'LEAGUE_GOALS'] = goals_scored_verify(country, games_res_df)[-1]
    if goals_scored_verify(country, games_res_df)[1] > perf_ctr_grouped_plus.loc[perf_ctr_grouped_plus['COUNTRY_ID'] == country,'GOALS'].iloc[0]:
        perf_ctr_grouped_plus.loc[perf_ctr_grouped_plus['COUNTRY_ID'] == country,'GOALS'] = goals_scored_verify(country, games_res_df)[1]

### THE DIFFERENCES IN GOAL NUMBERS BETWEEN DATAFRAMES, perf_ctr_grouped (BASED ON perf_df, AGGREGATES INDIVIDUAL PLAYERS' PERFORMANCE DATA), AND games_res_df (AGGREGATES DATA AT THE MATCH LEVEL), ARE SUSPICIOUS AND NEED VERIFICATION. THE FUNCTION goals_scored_verify() CREATED ABOVE ACCUMULATES GOALS PER COUNTRY FROM TWO DIFFERENT SOURCES, AS DESCRIBED. SMALL DIFFERENCES WERE NOTED IN ITA03, POR06, RUS10, POL18 (ONLY ONE GOAL DIFFERENCE), BUT LARGER DIFFERENCES WERE OBSERVED IN SPA02 (51 GOALS), HUN25 (36 GOALS), ENG01 (27 GOALS).
### AS FOR THE POTENTIAL REASONS FOR DIFFERENCES: FIRSTLY, AS OBSERVED DURING DATABASE VERIFICATION, NOT EVERY SINGLE GAME IS SCRAPED. THIS LEADS TO THE NATURAL FACT THAT THE NUMBER OF GOALS FROM perf_ctr_grouped IS HIGHER THAN THE COUNTED NUMBER OF GOALS FROM THE IMPERFECT games_res_df DATABASE. TWO OTHER REASONS FOR THE DIFFERENCES IN GOAL NUMBERS WERE IDENTIFIED: CUP GAMES (NATIONAL AND UEFA) WHERE THERE WAS EXTRA TIME OR PENALTY SHOOTOUT WERE EXCLUDED FROM CALCULATIONS BASED ON games_res_df (FINAL SCORES WITH PENALTIES WERE SCRAPED, E.G., 6:5). HOWEVER, GOAL SCORERS DURING REGULAR TIME ARE COUNTED IN THE perf_df DATAFRAME ONLY.
### OWN GOALS ARE NOT ATTRIBUTED TO PLAYERS WHO SCORED THEM. THIS RESULTS IN SLIGHTLY DIFFERENT GOAL NUMBERS BETWEEN THE TWO SOURCES: LOWER NUMBERS IN perf_ctr_grouped_plus, WHERE OWN GOALS ARE NOT REPORTED, AND HIGHER NUMBERS IN games_res_df, WHERE OWN GOALS ARE NORMALLY COUNTED.
### SIMILARLY TO THE SITUATION WITH THE NUMBER OF GAMES, THE ANALYST DECIDED THAT FOR FURTHER ANALYSIS, THE HIGHER NUMBER OF GOALS PER COUNTRY WILL BE USED (WHETHER FROM perf_ctr_grouped_plus OR games_res_df). NOT ALL GOALS ARE RECORDED, AND THERE IS NO INDICATION THAT ANY EXTRA GOALS THAT DID NOT OCCUR ARE RECORDED. THEREFORE, THE HIGHER NUMBER OF GOALS FROM THESE TWO SOURCES WILL BE USED, ACCEPTING THAT THE GOALS DATA IS NOT 100% ACCURATE. A SEPARATE COLUMN DEDICATED TO THE SUM OF ONLY LEAGUE GOALS WAS ALSO CREATED AND WILL BE USED FOR FUTURE ANALYSIS.

perf_ctr_grouped_plus['AVG_GAMES'] = perf_ctr_grouped_plus['FINAL_GAMES_NO'] / perf_ctr_grouped_plus['TEAMS'] ### CALCULATES THE AVERAGE NUMBER OF GAMES PLAYED BY AN AVERAGE TEAM DURING THE PREVIOUS SEASON.
perf_ctr_grouped_plus['LG_GOALS_GAME'] = perf_ctr_grouped_plus['LEAGUE_GOALS'] / perf_ctr_grouped_plus['LEAGUE_GAMES'] ### CALCULATES THE AVERAGE NUMBER OF GOALS SCORED PER GAME IN THE NATIONAL LEAGUE.
perf_ctr_grouped_plus['AVG_GOALS_SCORER'] = perf_ctr_grouped_plus['GOALS'] / perf_ctr_grouped['SCORERS'] ### CALCULATES THE NUMBER OF GOALS SCORED BY THE AVERAGE GOAL SCORER DURING THE RECENT SEASON.
perf_ctr_grouped_plus = perf_ctr_grouped_plus.sort_values(by='PLRS_PER_TEAM')

columns_games_team_to_use = ['COUNTRY_ID', 'GAME_ID', 'HOME_FLG', 'TEAM_ID', 'OPPONENT_ID', 'COMPETITION', 'GOALS_SCORED', 'GOALS_LOST', 'POINTS']
comp_df = games_team_df.loc[ (games_team_df['GOALS_SCORED'] >=0) & ~ (games_team_df['COUNTRY_ID'].isin(['SWE21', 'NOR23'])), columns_games_team_to_use].copy() ### NORWAY AND SWEDEN, WHICH DID NOT PLAY A FULL SEASON (SPRING-AUTUMN SYSTEM), ARE EXCLUDED FROM THIS ANALYSIS.
comp_df_home_games = comp_df[comp_df['HOME_FLG'] == 1]
comp_df_away_games_no_duplicates = comp_df[(comp_df['HOME_FLG'] == 0) & ~(comp_df['GAME_ID'].isin(comp_df.loc[comp_df['HOME_FLG'] == 1,'GAME_ID']))] ### WITH THE DATABASE CORRECTLY SCRAPED BASED ON THE GIVEN CONDITIONS, THERE SHOULD NOT BE ANY 'NL' COMPETITION GAMES IN THE AWAY GAMES DATAFRAME. HOWEVER, DURING VERIFICATION, IT WAS FOUND THAT GAMES WERE MISSING FOR TEAMS SUCH AS AC MILAN AND ATALANTA BERGAMO, RESULTING IN 9 'NL' GAMES INCORRECTLY PLACED IN THE AWAY GAMES DATAFRAME: comp_df_away_games_no_duplicates ||| comp_df_away_games_no_duplicates['COMPETITION'].value_counts()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
comp_df_away_games_to_rotate = comp_df_away_games_no_duplicates[comp_df_away_games_no_duplicates['COMPETITION'] == 'NL']
comp_df_away_games_to_rotate = comp_df_away_games_to_rotate.assign(HOME_FLG = 1, TEAM_ID = comp_df_away_games_to_rotate['OPPONENT_ID'], OPPONENT_ID = comp_df_away_games_to_rotate['TEAM_ID'], GOALS_SCORED = comp_df_away_games_to_rotate['GOALS_LOST'], GOALS_LOST = comp_df_away_games_to_rotate['GOALS_SCORED'])
comp_df_away_games_to_rotate['POINTS'] = comp_df_away_games_to_rotate['POINTS'].apply(lambda x : 3 if x == 0 else (1 if x == 1 else 0)) 

comp_df_away_games_no_duplicates_edited = comp_df_away_games_no_duplicates[comp_df_away_games_no_duplicates['GAME_ID'].isin(comp_df_away_games_no_duplicates.loc[~(comp_df_away_games_no_duplicates['COMPETITION'] == 'NL'), 'GAME_ID'].to_list())]
comp_df_away_games_no_duplicates_edited_added = pd.concat([comp_df_away_games_no_duplicates_edited, comp_df_away_games_to_rotate]) 

comp_df = pd.concat(objs = [comp_df_home_games, comp_df_away_games_no_duplicates_edited_added])

### comp_df IS DERIVED FROM games_team_df AFTER REMOVING FUTURE GAMES (WHERE GOALS_SCORED < 0), GAMES FROM LEAGUES OF NORWAY OR SWEDEN, AND SELECTING SPECIFIED COLUMNS ONLY. comp_df INCLUDES EACH UNIQUE GAME_ID ONLY ONCE. EVERY GAME WHERE HOME_FLG == 1 IS INCLUDED IN THE FINAL DATAFRAME.
### EVERY GAME WHERE HOME_FLG == 0 IS ALSO INCLUDED IN THE FINAL DATAFRAME, BUT GAME_IDs THAT WERE ALREADY ANALYZED ARE NOT ADDED AGAIN. THESE GAMES INVOLVE ANALYZED TEAMS' AWAY GAMES AGAINST LOWER LEAGUE TEAMS (NATIONAL CUP GAMES) OR UEFA CUP GAMES WITH TEAMS OUTSIDE THE 23 ANALYZED LEAGUES. THE FINAL DATAFRAME RECORDS EACH PLAYED GAME ONLY ONCE.
### 9 'NL' - LEAGUE GAMES - WERE ORIGINALLY RECORDED ONLY FROM THE AWAY TEAM'S PERSPECTIVE. THESE 9 GAMES WERE ADJUSTED: OPPONENT_ID WAS SWITCHED WITH TEAM_ID (AND VICE VERSA), GOALS_SCORED WERE SWITCHED WITH GOALS_LOST (AND VICE VERSA), AND 0 POINTS WERE TRANSFORMED TO 3 POINTS. THIS WAY, comp_df WILL INCLUDE THESE 9 MISSING LEAGUE GAMES, WHICH WERE INITIALLY RECORDED ONLY FOR THE AWAY TEAM.
### THE NEWLY CREATED DF comp_df IS MERGED WITH games_res_df USING how = 'inner'. AS A RESULT, NO ROWS WERE LOST OR ADDED, AND comp_df STILL CONTAINS 8129 ROWS. ADDITIONALLY, comp_df (GAME_IDs FROM THE SOURCE) WAS COMPARED TO THE PREVIOUSLY EXISTING DF games_date_df (GAME_IDs FROM THE DF). THERE IS NO SINGLE GAME_ID PRESENT IN comp_df THAT IS NOT PRESENT IN games_date_df, AND THE RELATION WAS VERIFIED IN THE OTHER DIRECTION AS WELL.
### comp_df[~comp_df['GAME_ID'].isin(games_date_df.loc[~(games_date_df['COUNTRY_ID'].isin(['SWE21', 'NOR23'])), 'GAME_ID'].to_list())]  ||| games_date_df[~(games_date_df['GAME_ID'].isin(comp_df['GAME_ID'].to_list())) & ~ (games_date_df['COUNTRY_ID'].isin(['SWE21', 'NOR23'])) ]

comp_df = comp_df.merge(games_res_df[['GAME_ID', '>90_FLG']], on = 'GAME_ID', how = 'inner')
comp_df['NL_GOALS_SCOR'] = np.where(comp_df['COMPETITION'] == 'NL', comp_df['GOALS_SCORED'], pd.NA)
comp_df['NL_GOALS_LOST'] = np.where(comp_df['COMPETITION'] == 'NL', comp_df['GOALS_LOST'], pd.NA)
comp_df['NL_GOALS_DIFF'] = abs(comp_df['NL_GOALS_SCOR'] - comp_df['NL_GOALS_LOST']) ### COUNTING THE DIFFERENCE BETWEEN GOALS SCORED AND GOALS CONCEDED IN NL (LEAGUE GAMES) AS AN ABSOLUTE VALUE TO DETERMINE THE GOAL DIFFERENCE WITHOUT REGARDING WHETHER MORE GOALS WERE SCORED BY THE HOME OR AWAY TEAM.
comp_df['NL_BIG_WIN_FLG'] = np.where(comp_df['NL_GOALS_DIFF'] >= 3, 1, np.where(comp_df['COMPETITION'] == 'NL', 0, pd.NA)) ### FLAG CREATION TO MARK NATIONAL LEAGUE GAMES WHERE THE FINAL RESULT GOAL DIFFERENCE BETWEEN COMPETING TEAMS WAS 3 OR MORE GOALS.
comp_df['NL_DRAW_FLG'] = np.where(comp_df['NL_GOALS_SCOR'] == comp_df['NL_GOALS_LOST'], 1, np.where(comp_df['COMPETITION'] == 'NL', 0, pd.NA))

comp_df = comp_df.merge(leagues_df[['COUNTRY', 'COUNTRY_ID']], on = 'COUNTRY_ID', how = 'left')
comp_df['COUNTRY'].fillna('UEFA', inplace = True)  ### ADDING A COUNTRY COLUMN USING THE MERGE FUNCTION WITH how = 'left' PARAMETER. THIS ENSURES RETENTION OF UEFA CUP GAMES WHERE THE COUNTRY_ID COLUMN HAS A VALUE OF 'UEFA', NOT PRESENT IN leagues_df RECENTLY MERGED WITH comp_df.

comp_df_league = comp_df[comp_df['COMPETITION'] == 'NL'].copy()
comp_df_league.drop(columns = {'HOME_FLG', '>90_FLG', 'GOALS_SCORED', 'GOALS_LOST', 'COMPETITION'}, inplace = True) ### REMOVING COLUMNS DEDICATED TO UEFA CUPS (E.G., UEFA_FLG), COLUMNS WITH A SINGLE VALUE FOR LEAGUE GAMES (>90_FLG, INDICATING LEAGUE GAMES ALWAYS END AFTER 90 MINUTES), AND THOSE THAT ARE DUPLICATED WITH THE INFORMATION FROM OTHER COLUMNS (GOALS SCORED AND NL_GOALS_SCORED).
comp_df_league['NL_GOALS_DIFF'] = pd.cut(comp_df_league['NL_GOALS_DIFF'], bins = [-1,0,1,2,1000], labels = ['0', '1', '2', '3+']) ### THERE ARE 9 POSSIBLE VALUES FOR GOAL DIFFERENCES, BUT A DIFFERENCE OF 3 OR MORE GOALS IS THE LEAST COMMON. TO FACILITATE LATER PRESENTATION WITH A BAR CHART, THE pd.cut FUNCTION IS UTILIZED TO CREATE 4 GOAL DIFFERENCE BINS THAT WILL BE EASIER (AND MORE READABLE) TO DISPLAY.

comp_df_league_gr = comp_df_league.groupby(['COUNTRY_ID', 'NL_GOALS_DIFF'], observed=False)['GAME_ID'].count().reset_index() ### A NEW TABLE GROUPED BY TWO COLUMNS COUNTRY_ID AND NL_GOALS_DIFF, COUNTING THE NUMBER OF LEAGUE GAMES FOR 4 GROUPS OF GOAL DIFFERENCES IN EACH COUNTRY, IS BEING CREATED.
comp_df_league_gr['PCT_SHARE'] = 100 * comp_df_league_gr['GAME_ID'] / comp_df_league_gr.groupby('COUNTRY_ID')['GAME_ID'].transform('sum') ### A COLUMN TO CALCULATE THE PERCENTAGE SHARE OF GAMES ENDED WITH AN EXACT GOAL DIFFERENCE GROUP IN EACH COUNTRY IS BEING GENERATED USING THE TRANSFORM FUNCTION, COUNTING THE OVERALL SUM OF THE LEAGUE GAMES IN THE COUNTRY.
comp_df_league_gr_pt = comp_df_league_gr.pivot_table(index = 'COUNTRY_ID', columns = 'NL_GOALS_DIFF', values = 'PCT_SHARE').reset_index() ### CREATING A PIVOT TABLE WITH COUNTRIES AS ROWS AND GOAL DIFFERENCE GROUPS AS COLUMNS.
comp_df_league_gr_pt = comp_df_league_gr_pt.merge(leagues_df[['COUNTRY', 'COUNTRY_ID', 'LEAGUE_VALUE']], on = 'COUNTRY_ID').sort_values(by='LEAGUE_VALUE', ascending = False)

comp_df_grouped = (comp_df[comp_df['COMPETITION'] == 'NL'].groupby(['COUNTRY_ID', 'COUNTRY']).
                   agg({'GAME_ID' : 'count', 'TEAM_ID' : 'nunique', 'NL_GOALS_SCOR' : 'sum', 'NL_GOALS_LOST' : 'sum', 'NL_GOALS_DIFF' : 'mean', 'NL_BIG_WIN_FLG' : 'sum',
                        'NL_DRAW_FLG' : 'sum', 'POINTS' : 'mean'}).reset_index())  ### THE AVERAGE HOME OR AWAY TEAM'S LEAGUE POSITION (AVG_HT_PLACE, AVG_AT_PLACE) IS GENERALLY CLOSE TO HALF THE TOTAL NUMBER OF TEAMS IN THE LEAGUE. THIS HOLDS TRUE FOR MOST LEAGUES, EXCLUDING AUSTRIA AND SWITZERLAND (AS MENTIONED BEFORE). THIS DISCREPANCY IS LINKED TO THE CHAMPIONSHIP AND RELEGATION GROUPS, WHICH INFLUENCE LEAGUE POSITIONS BEFORE AND AFTER DIVIDING INTO TWO GROUPS, AS REFLECTED ON THE TRANSFERMARKT WEBPAGE.
comp_df_grouped.rename(columns = {'GAME_ID' : 'NO_OF_GAMES', 'TEAM_ID' : 'NO_OF_TEAMS', 'NL_BIG_WIN_FLG' : 'NL_BIG_WIN_CNT', 'NL_DRAW_FLG' : 'NL_DRAW_CNT'}, inplace = True)

no_of_coach_df = games_team_df[(games_team_df['GOALS_SCORED'] > -1) & (games_team_df['COACH'] != 'n/a') ].merge(clubs_df[['TEAM_ID', 'COUNTRY']], on = 'TEAM_ID').groupby(['COUNTRY','TEAM_ID','TEAM'])[['COACH']].nunique().reset_index() 
no_of_coach_df.rename(columns = {'COACH' : 'NO_OF_COACH'}, inplace = True) ### THE FUNCTION groupby GROUPS BY COUNTRY AND TEAM TO INTENTIONALLY COUNT THE SAME COACH TWICE IF HE COACHED TWO TEAMS IN THE SAME LEAGUE DURING THE SAME SEASON (E.G., JANUSZ NIEDZWIEDZ WORKED WITH WIDZEW LODZ AND RUCH CHORZOW).
no_of_coach_df_ctr = no_of_coach_df.groupby('COUNTRY')[['NO_OF_COACH']].sum().reset_index()
comp_df_grouped = comp_df_grouped.merge(no_of_coach_df_ctr, on = 'COUNTRY', how = 'inner') ### games_team_df IS FILTERED TO REMOVE 'N/A' VALUES IN THE COACH COLUMN TO AVOID COUNTING THE LACK OF COACH INFORMATION AS ONE OF THE TEAM COACHES. SECONDLY, games_team_df IS MERGED WITH clubs_df TO ADD THE 'COUNTRY' COLUMN. THE COUNTRY_ID COLUMN CONTAINS 'UEFA' VALUES, SO THIS COLUMN WOULD NOT HAVE BEEN A PERFECT SOURCE FOR GROUPING AND COUNTING THE NUMBER OF COACHES IN EACH COUNTRY.

comp_df_grouped['COACH_T'] = comp_df_grouped['NO_OF_COACH'] / comp_df_grouped['NO_OF_TEAMS']
comp_df_grouped['BIG_WIN_SH'] = 100 * comp_df_grouped['NL_BIG_WIN_CNT'] / comp_df_grouped['NO_OF_GAMES']
comp_df_grouped['WIN_SH'] = 100 * (1 - comp_df_grouped['NL_DRAW_CNT'] / comp_df_grouped['NO_OF_GAMES'])
comp_df_grouped['GOALS_GAME'] = (comp_df_grouped['NL_GOALS_SCOR'] + comp_df_grouped['NL_GOALS_LOST']) / comp_df_grouped['NO_OF_GAMES']

swe_nor_non_league_team_exc = games_date_df['HOME_TEAM_ID'].isin(clubs_df.loc[~clubs_df['COUNTRY_ID'].isin(['SWE21','NOR23']), 'TEAM_ID'].to_list())
games_date_supp_columns = ['GAME_ID', 'HOME_TEAM_ID', 'HOME_TEAM', 'GAME_TIME', 'GAME_DOW', 'GAME_DOM', 'GAME_MONTH', 'ATTENDANCE']
games_date_supp_df = (games_date_df.loc[ swe_nor_non_league_team_exc , games_date_supp_columns]).copy()
supp_compare_df = games_team_df[~games_team_df['COUNTRY_ID'].isin(['SWE21', 'NOR23']) & (games_team_df['GOALS_SCORED'] >= 0) & (games_team_df['HOME_FLG'] == 1)]

### games_date_supp_df WILL BE A DATAFRAME DEDICATED TO THE ANALYSIS OF SUPPORTERS, STADIUM OCCUPANCIES, AND RELATED METRICS. THE SOURCE FOR THIS ANALYSIS WILL BE games_date_df, TO WHICH MORE COLUMNS WILL BE MERGED LATER. FIRSTLY, GAMES FROM SWEDEN AND NORWAY, AS WELL AS GAMES OF SWEDISH AND NORWEGIAN TEAMS IN EUROPEAN CUPS (WHERE THESE TEAMS WERE HOSTS), WERE EXCLUDED FROM FURTHER ANALYSIS. GAMES WHERE TEAMS FROM ANALYZED LEAGUES WERE NOT THE HOSTS (E.G., NATIONAL CUP GAMES PLAYED AT LOWER LEAGUE TEAM STADIUMS OR EURO CUPS GAMES PLAYED AT STADIUMS OF TEAMS FROM NON-SCRAPED NATIONS) WERE ALSO EXCLUDED. AFTER THIS FILTERING, 7556 GAMES REMAINED FOR ANALYSIS.
### supp_compare_df, WHERE SWEDISH AND NORWEGIAN NATIONAL LEAGUE AND CUP GAMES, FUTURE GAMES (GOALS_SCORED < 0), AND GAMES WITH HOME_FLG == 0 WERE REMOVED, COUNTS 7569 ROWS, WHICH IS 13 ROWS MORE THAN THE PREVIOUSLY CREATED DATAFRAME. THE CODE LINE BELOW CHECKED THAT supp_compare_df CONTAINS 29 EUROPEAN CUP GAMES INVOLVING SWEDISH AND NORWEGIAN TEAMS AS HOSTS BUT MISSES 16 GAMES OF TEAMS SUCH AS AC MILAN, ATALANTA BC, AND PSV EINDHOVEN (PROBLEMS WITH SCRAPING THESE TEAMS' GAMES WERE IDENTIFIED DURING DATA VERIFICATION AND CLEANING), WHAT IS EXPLAINING THE 13-ROW DIFFERENCE.
### supp_compare_df[~supp_compare_df['GAME_ID'].isin(games_date_supp_df['GAME_ID'].to_list())].sort_values('TEAM') ||| games_date_supp_df[~games_date_supp_df['GAME_ID'].isin(supp_compare_df['GAME_ID'].to_list())]

games_date_supp_df.loc[games_date_supp_df['GAME_TIME'] == 'n/a', 'GAME_TIME'] = '00:00'      ### TO FACILITATE CALCULATIONS IN THE FOLLOWING LINES OF CODE, 'n/a' (NULL EQUIVALENT) VALUES IN THE GAME_TIME COLUMN WERE CHANGED TO '00:00'. THIS MAKES IT POSSIBLE TO PROCESS IN CALCULATIONS AND EASY TO MONITOR AND CONVERT BACK TO NaN VALUES AFTER THE CALCULATIONS ARE EXECUTED.
games_date_supp_df['GAME_HOUR'] = (games_date_supp_df['GAME_TIME'].str[:2]).astype(float)    ### VALUES IN THE GAME_TIME COLUMN ARE OF OBJECT / STRING TYPE. HOUR AND MINUTE VALUES ARE EXTRACTED FROM THE STRING WITH THESE TWO LINES OF THE CODE AND PLACED INTO TWO NEWLY CREATED COLUMNS: GAME_HOUR AND GAME_MINUTE. GAME_MINUTE COLUMN VALUES ARE THEN CONVERTED TO BE PRESENTED AS FRACTIONS OF AN HOUR. FINALLY, THE VALUE TYPE IN THESE TWO NEW COLUMNS IS SWITCHED TO FLOAT TYPE.
games_date_supp_df['GAME_MINUTE'] = ((games_date_supp_df['GAME_TIME'].str[3:]).apply(lambda x : x[-1] if x[0] == '0' else x).astype(float)) / 60
bins = [-0.1, 0.2499, 0.499, 0.7499, 1]
labels = [0, 0.25, 0.5, 0.75]               ### VALUES IN THE GAME_MINUTE COLUMN ARE BEING ROUNDED/CEILED TO THE .00, .25, .50, .75 VALUES TO MAINTAIN THAT LEVEL OF GRANULARITY AND PRECISION REGARDING MINUTES. THE pd.cut FUNCTION IS USED TO ACHIEVE THIS TARGET.
games_date_supp_df['GAME_MINUTE'] = (pd.cut(games_date_supp_df['GAME_MINUTE'], bins = bins, labels = labels)).astype(float)
games_date_supp_df['GAME_TIME'] = games_date_supp_df['GAME_HOUR'] + games_date_supp_df['GAME_MINUTE'] 
games_date_supp_df.loc[games_date_supp_df['GAME_TIME'] == 0.00, ['GAME_TIME', 'GAME_HOUR']] = pd.NA   ### THE GAME_TIME COLUMN WAS CALCULATED AS THE SUM OF THE VALUES FROM TWO COLUMNS: GAME_HOUR AND GAME_MINUTE. THE FIRST COLUMN (GAME_HOUR) WILL BE KEPT, AND THE SECOND COLUMN (GAME_MINUTE) WILL BE REMOVED. NaN VALUES WERE SWITCHED TO '00:00' FOR CALCULATIONS AND THEN TRANSLATED BACK TO NaN VALUES AFTER CALCULATIONS.

games_date_supp_df = games_date_supp_df.merge(games_res_df[['GAME_ID', 'COMPETITION']], on = 'GAME_ID')   ### THE COMPETITION COLUMN FROM games_res_df IS BEING MERGED INTO THE DATAFRAME. SUBSEQUENTLY, THREE SEPARATE COLUMNS/FLAGS ARE CREATED TO FACILITATE EASY FILTERING: NATIONAL LEAGUE GAMES, EUROPEAN CUP GAMES, AND NATIONAL CUP & OTHER GAMES.
games_date_supp_df = games_date_supp_df.assign(UEFA_FLG = lambda x: x['COMPETITION'].apply(lambda y: 1 if y == 'ECo' or y == 'ECh' or y == 'ELg' or y == 'FIFA Klub-WM' or y == 'UEFA Super Cup' else 0) , 
                                               NL_FLG = lambda x: x['COMPETITION'].apply(lambda y: 1 if y == 'NL' else 0 ))
games_date_supp_df = games_date_supp_df.assign(CUP_FLG = lambda x: x.apply(lambda y: 1 if (y['NL_FLG'] == 0 and y['UEFA_FLG'] == 0) else 0, axis = 1) )

games_date_supp_df = games_date_supp_df.merge(clubs_det_df[['TEAM_ID', 'COUNTRY_ID', 'SEATS']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID').drop(columns=['TEAM_ID', 'GAME_MINUTE'])
games_date_supp_df['MISSING_DATA_FLG'] = games_date_supp_df['ATTENDANCE'].apply(lambda x : 1 if x == -1 else 0)   
games_date_supp_df.loc[games_date_supp_df['ATTENDANCE'] == -1, 'ATTENDANCE'] = np.NaN ### games_date_supp_df IS MERGED WITH clubs_det_df TO ADD TWO MORE COLUMNS: COUNTRY_ID (ENABLING CALCULATIONS/AGGREGATIONS AT THE COUNTRY LEVEL) AND SEATS (ENABLING CALCULATIONS OF THE PERCENTAGE OF OCCUPIED SEATS AT THE STADIUM). UNNECESSARY COLUMNS ARE REMOVED, AND A FLAG IS CREATED TO MARK ROWS THAT LACK DATA REGARDING THE NUMBER OF SUPPORTERS AT THE GAME. FINALLY, -1 VALUES IN THE ATTENDANCE COLUMN ARE REPLACED WITH pd.NA (NULL EQUIVALENT).

supp_missing_data_pt = games_date_supp_df.pivot_table(index = 'COUNTRY_ID', columns = 'MISSING_DATA_FLG', values = 'GAME_ID', aggfunc = 'count', fill_value = 0).reset_index().rename_axis(None, axis = 1)
supp_missing_data_pt['MISSING_DATA_PCT'] = 100 * supp_missing_data_pt[1] / (supp_missing_data_pt[0] + supp_missing_data_pt[1]) ### A PIVOT TABLE WAS CREATED TO PRESENT EACH OF THE COUNTRIES AND SHOW THE PERCENTAGE OF GAMES LACKING INFORMATION ABOUT THE NUMBER OF SUPPORTERS WHO ATTENDED THE STADIUM. IN THE CASE OF TWO COUNTRIES (BUL24, UKR14), MORE THAN THE HALF OF THE GAMES ARE MISSING INFORMATION ABOUT THE NUMBER OF SUPPORTERS AT THE STADIUM. ONE COUNTRY (GRE12) LACKS INFORMATION FOR 33% OF ITS GAMES, AND THREE COUNTRIES LACK THAT DATA FOR APPROXIMATELY 10% OF THEIR GAMES. THIS REQUIRES FURTHER VERIFICATION BEFORE DECIDING WHETHER THESE COUNTRIES SHOULD BE ANALYZED REGARDING SUPPORTERS METRICS.

bul_ukr_df = games_date_supp_df[games_date_supp_df['COUNTRY_ID'].isin(['BUL24', 'UKR14'])].pivot_table(index = ['COUNTRY_ID', 'HOME_TEAM_ID', 'HOME_TEAM'], columns = 'MISSING_DATA_FLG', values = 'GAME_ID', aggfunc = 'count', fill_value = 0).reset_index().rename_axis(None, axis = 1)
bul_ukr_df = bul_ukr_df.assign(PCT_MISS = 100 * bul_ukr_df[1] / (bul_ukr_df[1] + bul_ukr_df[0])).sort_values(['COUNTRY_ID', 'PCT_MISS']) ### THE DATA REGARDING FANS ATTENDING STADIUMS IN BULGARIA AND UKRAINE IS FAR FROM BEING COMPLETE. IN THE CASE OF BUL24, 79% OF GAMES ARE MISSING INFORMATION ABOUT THE NUMBER OF SUPPORTERS WHO VISITED THE STADIUM. IN THE CASE OF UKR14, 60% OF GAMES LACK THAT METRIC. INSPECTING SINGLE TEAMS IN BUL24, ONLY TWO TEAMS, LEVSKI SOFIA (156) AND HEBAR PAZARDZHIK (26563), HAVE INFORMATION ABOUT THE NUMBER OF FANS AT THE STADIUM IN MORE THAN HALF OF THEIR GAMES. MOST OF THE TEAMS HAVE THAT INFORMATION FROM 3 OR LOWER NUMBER OF GAMES, WHICH IS LESS THAN 20% OF THE GAMES THEY HOSTED. IN THE CASE OF UKR14, MORE GAMES HAVE RECORDED THE NUMBER OF VISITING FANS, BUT STILL, MORE THAN HALF OF THE GAMES LACK THAT INFORMATION, MAKING ANALYSIS OF THESE METRICS QUESTIONABLE. MOST OF THE UKRAINIAN CLUBS MISS ATTENDANCE STATISTICS FROM 50 - 70% OF THEIR HOME GAMES. DUE TO THIS, BUL24 AND UKR14 WILL BE REMOVED FROM SUPPORTERS' METRICS ANALYSIS.

gre_tur_sco_rom = games_date_supp_df[games_date_supp_df['COUNTRY_ID'].isin(['GRE12', 'TÜR09', 'SCO15', 'ROM22'])].pivot_table(index = ['COUNTRY_ID', 'HOME_TEAM_ID', 'HOME_TEAM'], columns = 'MISSING_DATA_FLG', values = 'GAME_ID', aggfunc = 'count', fill_value = 0).reset_index().rename_axis(None, axis = 1)
gre_tur_sco_rom = gre_tur_sco_rom.assign(PCT_MISS = 100 * gre_tur_sco_rom[1] / (gre_tur_sco_rom[1] + gre_tur_sco_rom[0])).sort_values(['COUNTRY_ID', 'PCT_MISS'])
gre_tur_sco_rom_mean_std = games_date_supp_df[games_date_supp_df['COUNTRY_ID'].isin(['GRE12', 'TÜR09', 'SCO15', 'ROM22']) & ~(games_date_supp_df['ATTENDANCE'].isna())].groupby('HOME_TEAM_ID').agg( MEAN_ATT = ('ATTENDANCE', 'mean'), STD_ATT = ('ATTENDANCE', 'std')).reset_index()
gre_tur_sco_rom = gre_tur_sco_rom.merge(gre_tur_sco_rom_mean_std, on = 'HOME_TEAM_ID').assign(CV_ATT = lambda x : x['STD_ATT'] / x['MEAN_ATT'])

### A TABLE (gre_tur_sco_rom) WITH INFORMATION SUCH AS THE PERCENTAGE OF GAMES WITHOUT DATA ABOUT SUPPORTERS (PCT_MISS), MEAN ATTENDANCE (MEAN_ATT), STANDARD DEVIATION OF ATTENDANCE (STD_ATT), AND COEFFICIENT OF ATTENDANCE VARIATION (CV_ATT) WAS CREATED TO BETTER INSPECT THE DATA REGARDING SUPPORTERS FOR CLUBS FROM 4 COUNTRIES: GRE12, TÜR09, SCO15, AND ROM22. THESE FOUR COUNTRIES MISS ATTENDANCE DATA FROM 33% OF GAMES (GREECE) AND 9.2 - 11.7% OF GAMES (THE REMAINING THREE COUNTRIES). THE DECISION TO KEEP OR EXCLUDE THESE COUNTRIES (OR SOME OF THEM) FROM FURTHER ANALYSIS REQUIRES A CLOSER LOOK BEFORE FINAL FILTERING OF THE DATA FRAME.
### AS MENTIONED, GREECE MISSED ON AVERAGE ATTENDANCE DATA FOR 1 OUT OF 3 GAMES. THE SITUATION WAS INSPECTED AT THE CLUB LEVEL. TEAMS SUCH AS AEK ATHENS (2441), OLYMPIACOS PIRAEUS (683), AND ASTERAS TRIPOLIS (6676) MISS ATTENDANCE DATA FOR 20.8 - 47.1% OF THEIR HOME GAMES. THESE GAMES ARE MAINLY NATIONAL LEAGUE AND NATIONAL CUP GAMES (VERY RARELY EUROPEAN CUP GAMES). INTERESTINGLY, THE CV (COEFFICIENT OF VARIATION) FOR SOME CLUBS IS CLOSE TO OR EVEN HIGHER THAN 1. THIS HAPPENS FOR EXAMPLE WITH PANATHINAIKOS FC (265), WHOSE SUPPORTERS ATTEND EUROPEAN CUP GAMES IN MUCH HIGHER NUMBERS THAN LEAGUE GAMES (POSSIBLY EUROPEAN CUP GAMES WERE BEING PLAYED IN A DIFFERENT STADIUM), OR VOLOS NPS (60949), WHERE SUPPORTERS CAME IN NUMBERS OF 3.5K AND 5.2K FOR TWO GAMES AND ONLY ONCE MORE THAN 500 PEOPLE FOR EVERY OTHER HOME GAME WITH DATA RECORDED. THE DECISION TO KEEP GREECE FOR FURTHER ANALYSIS WILL BE MADE AFTER ANALYZING THE REMAINING 3 COUNTRIES THAT LACK SUPPORTERS' DATA FOR APPROXIMATELY 10% OF THEIR GAMES.
### 19 OUT OF 20 TURKISH CLUBS POSSESS ATTENDANCE DATA FOR MORE THAN 80% OF THE HOME GAMES THEY PLAYED. THE OUTLIER CLUB REGARDING THIS METRIC IS MKE ANKARAGUCU (868), WHICH MISSES ATTENDANCE DATA FOR 7 GAMES (28%, 6 TURKISH CUP GAMES AND ONE LEAGUE GAME). FOR THE REMAINING TURKISH CLUBS, IF THEY MISS DATA CONNECTED WITH SUPPORTERS, IT IS ALWAYS A CASE OF A TURKISH CUP GAME (E.G., IN GREECE 73% OF MISSING ATTENDANCE DATA GAMES ARE LEAGUE GAMES). THUS, TURKISH GAMES ATTENDANCE DATA IS PERFECT TO ANALYZE EXCEPT FOR ANALYZING ONLY TURKISH CUP GAMES, WHICH IS A VERY UNLIKELY SOLO SUBJECT FOR FURTHER ANALYSIS. IN TURKEY, THERE ARE 2 TEAMS WITH CV_ATT HIGHER THAN 2. IN BOTH CASES, THERE ARE 2-3 OUTLIER GAMES PLAYED AT THE HOME STADIUM WITH ATTENDANCE HIGHER THAN 20K, WHILE MOST OF THE REMAINING HOME GAMES OF THESE TEAMS HAVE LESS THAN 1K ATTENDEES. || games_date_supp_df[ (games_date_supp_df['COUNTRY_ID'] == 'TÜR09') & ~(games_date_supp_df['HOME_TEAM_ID'] == 868) & (games_date_supp_df['ATTENDANCE'].isna())]
### IN SCOTLAND, THERE ARE 3 TEAMS THAT MISS ATTENDANCE DATA FOR 20.8 - 30.4% OF THEIR HOME GAMES AND 3 TEAMS THAT POSSESS 100% OF THEIR HOME GAMES' ATTENDANCE DATA. THE CV_ATT METRIC IN SCO15 IS MUCH LOWER (0.07 - 0.69) THAN IN THE PREVIOUSLY ANALYZED GRE12 AND TÜR09, WHICH MEANS SCOTTISH SUPPORTERS ATTEND THEIR TEAMS GAMES IN A MUCH MORE STABLE AND PREDICTABLE WAY. 64% OF ALL SCOTTISH GAMES WITH MISSING ATTENDANCE DATA ARE LEAGUE GAMES (20 LEAGUE GAMES WITH MISSING ATTENDANCE DATA OUT OF 228 LEAGUE GAMES OVERALL). THESE FINDINGS SUGGEST THAT SCO15 ATTENDANCE DATA IS HIGHLY RELIABLE FOR ANALYSIS.
### IN ROMANIA, THERE ARE ONLY 2 TEAMS MISSING ATTENDANCE DATA FOR MORE THAN 15% OF THEIR HOME GAMES (AND LESS THAN 20%). THERE IS ONLY ONE ROMANIAN TEAM WITH A CV_ATT HIGHER THAN 1. OUT OF ALL GAMES HOSTED BY ROMANIAN TEAMS WITH MISSING ATTENDANCE DATA, 68% ARE NATIONAL LEAGUE GAMES. 22 OUT OF 315 (7%) ROMANIAN LEAGUE GAMES MISS ATTENDANCE DATA. ROM22 IS GOOD TO GO FOR ATTENDANCE ANALYSIS.
### GREECE MISSES ATTENDANCE DATA FOR 30% OF LEAGUE GAMES. TURKEY POSSESSES ATTENDANCE DATA FOR 99% OF LEAGUE GAMES, AND SCOTLAND AND ROMANIA HAVE GATHERED ATTENDANCE DATA FOR MORE THAN 90% OF LEAGUE GAMES PLAYED IN THEIR COUNTRIES. DUE TO THESE DIFFERENCES, THE SUBJECTIVE ANALYST DECISION IS TO REMOVE GREECE FROM FURTHER ATTENDANCE ANALYSIS.
### COUNTRIES: FRA05, POR06, NET07, BEL08, AND SER19 MISS ATTENDANCE DATA FOR 8 - 14 GAMES (2.2 - 4% OF ALL GAMES PLAYED BY TEAMS FROM THESE COUNTRIES). GENERALLY, IN THE CASE OF THESE COUNTRIES, IT IS CONNECTED WITH BOTH NATIONAL LEAGUE AND CUP GAMES. IN THE CASE OF MOST TEAMS, IT IS A SINGLE (OR TWO) GAME FOR A CLUB WHERE THERE IS A MISSING DATA REGARDING THE NUMBER OF SUPPORTERS AT THE STADIUM. IT MUST BE NOTED THAT THERE ARE SPECIFIC CASES: FK NOVI PAZAR (SER19, 4633, OVERALL 19 HOME GAMES) MISSES INFORMATION REGARDING SUPPORTERS FOR 8 HOME GAMES, AND TWO TEAMS: GD ESTORIL PRAIA (POR06, 1465, 22 HOME GAMES) AND EXCELSIOR ROTTERDAM (NET07, 798, 20 HOME GAMES) ARE MISSING THE NUMBER OF SUPPORTERS FOR 4 GAMES. THESE NUMBERS SEEM ACCEPTABLE TO ANALYZE THE SUPPORTERS' DATA AT THE COUNTRY LEVEL GRANULARITY.
### IN SWI13 AND DEN16 OVERALL 3-4 GAMES LACK INFORMATION ABOUT THE NUMBER OF FANS WHO VISITED THE STADIUMS. THESE LACKS ARE DISTRIBUTED AMONG DIFFERENT TEAMS, IN NATIONAL LEAGUE OR CUP GAMES, THUS THIS WILL NOT AFFECT FURTHER SUPPORTERS ANALYSIS. 

games_date_supp_df = games_date_supp_df.loc[~games_date_supp_df.COUNTRY_ID.isin(['BUL24', 'UKR14', 'GRE12']), :].reset_index(drop = True)

games_date_supp_df['COMP_TYPE'] = games_date_supp_df['COMPETITION'].apply(lambda x: 1 if x == 'NL' else (2 if x in ['ECo', 'ELg', 'ECh', 'FIFA Klub-WM', 'UEFA Super Cup'] else 3)) ### APPLYING LAMBDA FUNCTION TO CREATE ONE COLUMN THAT WILL COMBINE THE INFORMATION PRESENTED IN THREE OTHER COLUMNS AND ENABLE EASY FILTERING OF THE COMPETITION THE GAME TOOK PLACE IN USING JUST ONE COLUMN. 1 IS ASSIGNED TO NATIONAL LEAGUE GAMES, 2 IS RESERVED FOR EUROPEAN CUP GAMES, AND 3 REPRESENTS NATIONAL CUP GAMES.

### 188 GAMES FROM THE FILTERED GAME DATABASE: games_date_supp_df ARE MISSING DATA REGARDING THE NUMBER OF SUPPORTERS WHO ATTENDED THE STADIUM. CONDUCTING FURTHER ANALYSIS WILL REQUIRE HAVING AT LEAST AN ESTIMATED NUMBER OF SUPPORTERS FOR EVERY SINGLE TEAM, THUS SOME ESTIMATIONS WILL BE MADE. ATTENDANCE VALUES FOR 78 LEAGUE GAMES (COMP_TYPE == 1) MISSING THAT METRIC WILL BE ESTIMATED AS THE AVERAGE NUMBER OF SUPPORTERS AT OTHER LEAGUE GAMES HOSTED BY THAT TEAM. 2 EUROPEAN CUP GAMES (COMP_TYPE == 2) MISSING ATTENDANCE DATA WILL BE ESTIMATED SIMILARLY TO LEAGUE GAMES CALCULATIONS AS THE AVERAGE NUMBER OF SUPPORTERS AT THE TEAM'S HOME GAMES IN EUROPEAN CUPS. THE BIGGER CHALLENGE IS ASSESSING SUPPORTERS' NUMBERS FOR 108 NATIONAL CUP GAMES (COMP_TYPE == 3). THE METHODOLOGY FOR THESE CALCULATIONS WILL BE DESCRIBED IN THE FOLLOWING LINES OF CODE.

cup_games_missing_att = games_date_supp_df[(games_date_supp_df['ATTENDANCE'].isna()) & (games_date_supp_df['COMP_TYPE'] == 3)].groupby(['HOME_TEAM_ID','HOME_TEAM'])['GAME_ID'].count().to_frame().reset_index().rename(columns = {'GAME_ID' : 'CUP_GAMES_NA'})
cup_games = games_date_supp_df[(games_date_supp_df['COMP_TYPE'] == 3)].groupby('HOME_TEAM_ID').agg({'GAME_ID' : 'count', 'ATTENDANCE' : 'mean'}).reset_index().rename(columns = {'GAME_ID' : 'CUP_GAMES', 'ATTENDANCE' : 'CUP_ATT_MEAN'})
cup_games_missing_att = cup_games_missing_att.merge(cup_games, on = 'HOME_TEAM_ID').assign(PCT_SH = lambda x : 100 * x['CUP_GAMES_NA'] / x['CUP_GAMES'])
cup_games_missing_att = cup_games_missing_att[ (cup_games_missing_att['PCT_SH'] < 50 ) | ( (cup_games_missing_att['PCT_SH'] == 50) & (cup_games_missing_att['CUP_GAMES'] >= 4) )].sort_values('PCT_SH').set_index('HOME_TEAM_ID')

### TWO DATAFRAME OBJECTS ARE BEING CREATED. ONE DF CONTAINS ALL TEAMS THAT HOSTED AT LEAST ONE NATIONAL CUP GAME THAT MISSES DATA ABOUT THE NUMBER OF SUPPORTERS AND COUNTS THE NUMBER OF SUCH OCCURRENCES. THE SECOND DF CONTAINS ALL TEAMS THAT HOSTED AT LEAST ONE NATIONAL CUP GAME, THE OVERALL NUMBER OF NATIONAL CUP GAMES HOSTED BY THAT TEAM, AND THE AVERAGE NUMBER OF FANS AT THESE GAMES. THEN, THESE TWO DFS ARE MERGED AND THE COLUMN WITH THE PERCENTAGE OF NATIONAL CUP GAMES HOSTED BY THE TEAM MISSING ATTENDANCE DATA IS CALCULATED. THE DF OBJECT IS LATER FILTERED TO KEEP ONLY TEAMS THAT MISS THE ATTENDANCE DATA FOR LESS THAN HALF THE NATIONAL CUP GAMES THEY HOSTED OR MISS ATTENDANCE DATA FOR EXACTLY HALF OF THE NATIONAL CUP GAMES BUT HOSTED AT LEAST 4 NATIONAL CUP GAMES.

cup_multiplier = ((     games_date_supp_df['COUNTRY_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 3].groupby('COUNTRY_ID')['ATTENDANCE'].mean())  / 
                        games_date_supp_df['COUNTRY_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 1].groupby('COUNTRY_ID')['ATTENDANCE'].mean()) ) )
cup_games_att_estimator = (    np.where(cup_multiplier > 1.095, 1.095, cup_multiplier) * 
                                games_date_supp_df['HOME_TEAM_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 1].groupby('HOME_TEAM_ID')['ATTENDANCE'].mean() ))

### cup_multiplier IS RESPONSIBLE FOR CALCULATING THE RATIO BETWEEN THE AVERAGE NUMBER OF SUPPORTERS DURING NATIONAL CUP GAMES VERSUS THE AVERAGE NUMBER OF FANS DURING REGULAR LEAGUE GAMES IN EACH OF THE COUNTRIES. USING THE MAP METHOD, THIS CALCULATED RATIO FOR EACH COUNTRY IS ATTRIBUTED TO EACH ROW OF THE games_date_supp_df DATAFRAME. IN SOME COUNTRIES, THIS RATIO IS UNREASONABLY HIGH: 2.81 FOR TÜR09 (BECAUSE ONLY 6 NATIONAL CUP GAMES HAVE ATTENDANCE DATA, MAINLY GAMES HOSTED BY TEAMS WITH LARGE SUPPORTERS BASES SUCH AS BESIKTAS JK AND GALATASARAY), AND HUN25 (WHERE THERE ARE ONLY 8 NATIONAL CUP GAMES WITH ATTENDANCE DATA, BUT ONE GAME WITH 51.9K SUPPORTERS IS AN OUTLIER THAT UNNATURALLY INCREASES THE MEAN ATTENDANCE VALUE FOR CUP GAMES). FURTHER ANALYSIS HAVE SHOWN THAT FOR NATIONAL CUP GAMES IN MOST COUNTRIES, THERE IS ONE (MAX 3) GAME WITH MUCH HIGHER ATTENDANCE THAN OTHER NATIONAL CUP GAMES. MANUAL VERIFICATION HAS SHOWN THIS IS A FINAL CUP GAME (AND IN SCOTLAND ALSO SEMI-FINAL GAMES). THIS SITUATION REQUIRES ATTENTION. 
### cup_games_att_estimator USES THE np.where FUNCTION FOR EVERY SINGLE ROW OF THE SERIES cup_multiplier. IF THE VALUE IS HIGHER THAN 1.095, IT WILL BE CHANGED TO 1.095; IF IT IS LOWER THAN 1.095, IT WILL REMAIN THE ORIGINAL VALUE. THE CALCULATED RATIO IN THE cup_multiplier SERIES FOR SOME COUNTRIES SEEMED TOO HIGH. THEREFORE, AN OVERALL AVERAGE RATIO WAS CALCULATED (HUN25 AND TÜR09 WERE DISMISSED FROM THIS CALCULATION), WHICH WAS 1.11, AND THEN MANUALLY REDUCED TO 1.095 TO EXCLUDE THE BOOST EFFECT OF NATIONAL CUP FINAL ATTENDANCE ON THE MEAN VALUE. LATER, THE AVERAGE ATTENDANCE FOR LEAGUE HOME GAMES FOR EVERY SINGLE TEAM WAS CALCULATED AND, USING THE MAP METHOD, WAS ATTRIBUTED TO EVERY SINGLE ROW OF games_date_supp_df AND MULTIPLIED BY THE RATIO CHOSEN USING THE PREVIOUS np.where FUNCTION. THE SERIES CREATED WITH THIS METHODOLOGY WILL BE USED TO ESTIMATE ATTENDANCE DURING NATIONAL CUP GAMES THAT ARE MISSING INFORMATION REGARDING THE NUMBER OF SUPPORTERS.

games_date_supp_df['ATT_EST'] =     (np.where(games_date_supp_df['ATTENDANCE'].isna(),
                                                np.where(games_date_supp_df['COMP_TYPE'] == 1,
                                                            games_date_supp_df['HOME_TEAM_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 1].groupby('HOME_TEAM_ID')['ATTENDANCE'].mean()), 
                                                            np.where(games_date_supp_df['COMP_TYPE'] == 2,    
                                                                        games_date_supp_df['HOME_TEAM_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 2].groupby('HOME_TEAM_ID')['ATTENDANCE'].mean()),
                                                                        np.where(games_date_supp_df['HOME_TEAM_ID'].map(cup_games_missing_att['CUP_ATT_MEAN']).isna(),
                                                                                    np.where(cup_games_att_estimator <= games_date_supp_df['SEATS'], ### WITHOUT_DATA
                                                                                                cup_games_att_estimator,
                                                                                                games_date_supp_df['SEATS']
                                                                                            )
                                                                                    ,np.where(games_date_supp_df['HOME_TEAM_ID'].map(cup_games_missing_att['CUP_ATT_MEAN']) <= cup_games_att_estimator,  ### WITH_DATA
                                                                                                np.where(games_date_supp_df['HOME_TEAM_ID'].map(cup_games_missing_att['CUP_ATT_MEAN']) < games_date_supp_df['SEATS'],
                                                                                                            games_date_supp_df['HOME_TEAM_ID'].map(cup_games_missing_att['CUP_ATT_MEAN']),
                                                                                                            games_date_supp_df['SEATS']
                                                                                                        ), 
                                                                                                np.where(cup_games_att_estimator <= games_date_supp_df['SEATS'],
                                                                                                            cup_games_att_estimator,
                                                                                                            games_date_supp_df['SEATS']
                                                                                                        )
                                                                                            )
                                                                                )
                                                                    )
                                                        )
                                                ,games_date_supp_df['ATTENDANCE']
                                            )
                                    )

### THE NEWLY CREATED COLUMN 'ATT_EST' IS CALCULATED USING AN ALGORITHM THAT CONSISTS OF MORE THAN 20 LINES OF CODE BUT IS NOT THAT COMPLICATED. THE ALGORITHM USES MULTIPLE NESTED np.where FUNCTIONS TO CONSIDER EVERY POSSIBLE SITUATION. FIRSTLY, IF THERE IS A VALUE IN THE COLUMN 'ATTENDANCE', IT WILL BE KEPT, AND NO FURTHER STEPS OF THE ALGORITHM WILL BE PERFORMED. OTHERWISE, THE ALGORITHM WILL CHECK WHAT KIND OF GAME IT WAS (WHICH COMPETITION) AND PERFORM THE NECESSARY STEPS. FOR LEAGUE OR EURO CUP GAMES WITHOUT ATTENDANCE DATA, THE ALGORITHM WILL ASSESS THE AVERAGE ATTENDANCE OF HOME LEAGUE OR EURO CUP GAMES PLAYED BY THAT TEAM DURING THE LAST SEASON. ASSESSING THE MISSING VALUES FOR NATIONAL CUP GAMES IS A LITTLE MORE COMPLICATED.
### IF THE ALGORITHM IS CONSIDERING A NATIONAL CUP GAME WITH MISSING ATTENDANCE DATA, TWO SITUATIONS ARE POSSIBLE. THE FIRST, NICKNAMED 'WITHOUT_DATA', IS FOR THE HOSTS OF NATIONAL CUP GAMES WITHOUT ATTENDANCE DATA THAT ARE NOT PRESENT IN THE DF: cup_games_missing_att. THIS DF EXCLUDES TEAMS THAT MISS ATTENDANCE DATA FOR MORE THAN 50% OF THEIR HOSTED NATIONAL CUP GAMES (OR EXACTLY 50% BUT PLAYED FEWER THAN 4 NATIONAL CUP GAMES AT THEIR STADIUM). IN THIS SCENARIO, THE ALGORITHM WILL CHOOSE THE SMALLER VALUE FROM TWO OPTIONS: STADIUM CAPACITY (SEATS) OR THE ATTENDANCE ESTIMATED BY THE FORMULA PRESCRIBED IN THE SERIES: cup_games_att_estimator. THE SECOND PATH, NAMED 'WITH_DATA', APPLIES TO TEAMS PRESENT IN THE DF: cup_games_missing_att. IN THIS CASE, THE ALGORITHM WILL CHOOSE THE SMALLER VALUE BETWEEN THE AVERAGE ATTENDANCE DURING NATIONAL CUP GAMES HOSTED BY THAT TEAM (cup_games_missing_att) AND THE ESTIMATED VALUE BY THE FORMULA: cup_games_att_estimator. WHICHEVER VALUE IS CHOSEN, IT WILL BE COMPARED TO THE STADIUM CAPACITY (SEATS), AND THE SMALLER OF THESE VALUES WILL BE PLACED IN THE 'ATT_EST' COLUMN FOR THAT ROW.

games_date_supp_df['ARENA_PCT'] = 100 * games_date_supp_df['ATT_EST'] / games_date_supp_df['SEATS']
bins = [0,20,40,60,80,100,9000]
labels = ['[0-20]', '(20-40]', '(40-60]', '(60-80]', '(80-100]', '(100+)']
games_date_supp_df['ARENA_PCT_G'] = pd.cut(games_date_supp_df['ARENA_PCT'], bins = bins, labels = labels)  ### A COLUMN WAS CREATED TO ASSESS THE PERCENTAGE OF STADIUM CAPACITY FILLED WITH FANS DURING EACH GAME, CATEGORIZING IT INTO ONE OF SIX GROUPS, EACH RANGING FROM 0-20%, 20-40%, AND SO ON. THE pd.cut METHOD WAS USED TO ACHIEVE THIS GOAL.

### THERE ARE 313 GAMES WHERE THE ATTENDANCE IS EXACTLY THE SAME AS THE STADIUM CAPACITY AND 103 GAMES WHERE ATTENDANCE WAS HIGHER THAN THE NUMBER OF SEATS AT THE STADIUM. THIS REQUIRES VERIFICATION AND DOUBLE-CHECKING TO ENSURE THE SCRAPED DATA IS CORRECT. MORE SUPPORTERS THAN THE AVAILABLE SEATS AT THE STADIUM WERE OBSERVED IN 60 LEAGUE GAMES, 21 EURO CUP GAMES, AND 22 NATIONAL CUP GAMES. THE RESULTS OF THE INVESTIGATION ARE DESCRIBED BELOW. THE SCRAPED ATTENDANCES AND STADIUM CAPACITIES FOR THE EXAMPLES MENTIONED BELOW WERE CONFIRMED WITH THE TRANSFERMARKT PAGE, AND THE SAMPLE RESULTS SHOW THAT THE DATA WAS SCRAPED CORRECTLY. |||  games_date_supp_df[games_date_supp_df['ARENA_PCT'] > 100].pivot_table(index = ['HOME_TEAM_ID', 'HOME_TEAM'], columns = 'COMP_TYPE', values = 'GAME_ID', aggfunc = 'count', fill_value = 0).reset_index().rename_axis(None, axis = 1).sort_values(1, ascending = False)
### FIRSTLY, THERE ARE TEAMS WHERE HAVING MORE SUPPORTERS PRESENT AT THE STADIUM THAN THE STADIUM CAPACITY (AS DECLARED ON THE TRANSFERMARKT PAGE) IS COMMON. TEAMS IN THIS CATEGORY INCLUDE RSC ANDERLECHT (58), WHICH HOSTED 8 LEAGUE GAMES AND 1 NATIONAL CUP GAME WITH OVERCROWDED STADIUM; UNION SAINT-GILLOISE (3948), WHO HAD 4 LEAGUE GAMES, 5 UEFA CUP GAMES, AND 3 NATIONAL CUP GAMES EXCEEDING STADIUM CAPACITY. SIMILAR EXPERIENCES ARE SHARED BY GO AHEAD EAGLES (1435), ZELEZNICAR PANCEVO (59358), LUTON TOWN (1031), AND A FEW MORE TEAMS. THIS CLEARLY INDICATES TO THE CLUB BOARD OF DIRECTORS THAT THERE IS A HUGE DEMAND FROM TEAM SUPPORTERS AND THEIR STADIUMS OUGHT TO BE ENLARGED IN THE FUTURE.
### OTHER OBSERVED SITUATIONS INCLUDE NATIONAL OR EURO CUP GAME FINALS PLAYED AT A DIFFERENT ARENA, BUT ONE OF THE TEAMS IS MARKED ON TRANSFERMARKT AS THE HOST (E.G., PAKSI FC: 12163, GAME_ID: 4336020 OR ATALANTA BC: 800, GAME_ID: 4336025). A SIMILAR SITUATION MIGHT HAPPEN AT A HIGHLY ANTICIPATED LEAGUE DERBY GAME (E.G., WARTA POZNAN: 7146, GAME_ID: 4087574 OR FC RAPID BUCHAREST: 455, GAME_ID: 4193530). ANOTHER CASE CLUB STADIUMS THAT DO NOT MEET UEFA CUP STANDARDS, RESULTING IN THESE TEAMS' GAMES BEING HOSTED AT OTHER ARENAS WITH HIGHER CAPACITIES THAN THEIR ORIGINAL STADIUMS (E.G., 1.FC UNION BERLIN: 90, GAME_ID: 4171258 OR RAKOW CZESTOCHOWA: 9644, GAME_ID: 4160965).

games_date_supp_df['ATT_MEA'] = games_date_supp_df['HOME_TEAM_ID'].map(games_date_supp_df.groupby('HOME_TEAM_ID')['ATTENDANCE'].mean())
games_date_supp_df['ATT_STD'] = games_date_supp_df['HOME_TEAM_ID'].map(games_date_supp_df.groupby('HOME_TEAM_ID')['ATTENDANCE'].std())
games_date_supp_df['ATT_CV'] = games_date_supp_df['ATT_STD'] / games_date_supp_df['ATT_MEA']        ### NEW COLUMNS WERE CREATED TO ENABLE MONITORING OF THE REGULARITY WITH WHICH SUPPORTERS VISIT THEIR FAVORITE CLUB'S STADIUM. FORMULAS WERE USED TO CALCULATE EACH CLUB'S AVERAGE ATTENDANCE AT HOME GAMES, THE STANDARD DEVIATION OF ATTENDANCE, AND THE COEFFICIENT OF VARIATION. THIS ALLOWS FOR THE COMPARISON OF ATTENDANCE VARIABILITY BETWEEN TEAMS WITH DIFFERENT AVERAGE NUMBERS OF SUPPORTERS, E.G., BORUSSIA DORTMUND (16) WITH AN AVERAGE ATTENDANCE OF 81.5K SUPPORTERS PER HOME GAME VS. 1.FC HEIDENHEIM 1846 (2036) WITH AN AVERAGE ATTENDANCE OF 15K SUPPORTERS.

columns_for_further_usage = ['COUNTRY_ID', 'GAME_ID', 'HOME_TEAM_ID', 'GAME_MONTH', 'GAME_DOM', 'GAME_DOW', 'GAME_HOUR','COMP_TYPE', 'ATT_EST', 'SEATS', 'ARENA_PCT', 'ARENA_PCT_G', 'ATT_MEA', 'ATT_CV']

games_date_supp_ctr_df = (games_date_supp_df.loc[:, columns_for_further_usage].groupby('COUNTRY_ID').
                         agg(   NO_OF_TEAMS = ('HOME_TEAM_ID', 'nunique'), NO_OF_GAMES = ('GAME_ID', 'count'), AVG_HOUR = ('GAME_HOUR', 'mean'),
                                FANS_S = ('ATT_EST', 'sum'), FANS_M = ('ATT_EST', 'mean'), ARENA_PCT_M = ('ARENA_PCT', 'mean'))).reset_index()
games_date_supp_ctr_df['ATT_CV_M'] = games_date_supp_ctr_df['COUNTRY_ID'].map(games_date_supp_df.groupby(['COUNTRY_ID', 'HOME_TEAM_ID'])['ATT_CV'].min().reset_index().groupby('COUNTRY_ID')['ATT_CV'].mean())
games_date_supp_ctr_df['GAME_TIME_LG_M'] = games_date_supp_ctr_df['COUNTRY_ID'].map(games_date_supp_df[games_date_supp_df['COMP_TYPE'] == 1].groupby('COUNTRY_ID')['GAME_TIME'].mean())
games_date_supp_ctr_df['SEATS_M'] = games_date_supp_ctr_df['COUNTRY_ID'].map(clubs_det_df.groupby('COUNTRY_ID')['SEATS'].mean())
games_date_supp_ctr_df = games_date_supp_ctr_df.assign( FANS_S_M = games_date_supp_ctr_df['FANS_S'] / games_date_supp_ctr_df['NO_OF_TEAMS'],
                                                        HM_GMS_M = games_date_supp_ctr_df['NO_OF_GAMES'] / games_date_supp_ctr_df['NO_OF_TEAMS'])   ### games_date_supp_df WITH DATA GRANULARITY AT THE SINGLE GAME LEVEL WAS GROUPED TO PRESENT THE DATA AT THE COUNTRY LEVEL. ADDITIONAL COLUMNS WERE CREATED, SUCH AS AVERAGE STADIUM CAPACITY FOR EACH COUNTRY AND AVERAGE LEAGUE GAME TIME, TO FACILITATE FUTURE ANALYSIS.

plbf_df_grouped_r = plbf_df_grouped.copy()
plbf_df_grouped_r = plbf_df_grouped_r.rename(columns = {'JOINED_YEAR' : 'JOIN_YR_M', 'CONTRACT_EXPIRY_YEAR' : 'CTR_EXP_YR_M', 'FOREIGNERS_SH' : 'FORE_SH'})

perf_ctr_grouped_plus_r = perf_ctr_grouped_plus.copy()
perf_ctr_grouped_plus_r = (perf_ctr_grouped_plus.assign(
                        GLS_PL_M = perf_ctr_grouped_plus_r['GOALS'] / perf_ctr_grouped_plus_r['TEAMS'] / perf_ctr_grouped_plus_r['AVG_GAMES'],      ### THE FOLLOWING METRICS CALCULATE THE AVERAGE NUMBER OF GOALS (ASSISTS, YELLOW CARDS, ETC.) SCORED BY A TEAM PER GAME IN THE PREVIOUS SEASON.
                        ASTS_M = perf_ctr_grouped_plus_r['ASSISTS'] / perf_ctr_grouped_plus_r['TEAMS'] / perf_ctr_grouped_plus_r['AVG_GAMES'],
                        CRDS_Y_M = perf_ctr_grouped_plus_r['YELLOW_CARDS'] / perf_ctr_grouped_plus_r['TEAMS'] / perf_ctr_grouped_plus_r['AVG_GAMES'],
                        CRDS_R_M = perf_ctr_grouped_plus_r['RED_CARDS'] / perf_ctr_grouped_plus_r['TEAMS'] / perf_ctr_grouped_plus_r['AVG_GAMES'],
                        MNS_GMS_M = perf_ctr_grouped_plus_r['MNS_PLD_M'] / perf_ctr_grouped_plus_r['AVG_GAMES'],
                        SCORERS_M = perf_ctr_grouped_plus_r['SCORERS'] / perf_ctr_grouped_plus_r['TEAMS'])
                        .rename(columns = {'PLRS_PER_TEAM' : 'PLRS', '>10_PCT_PLRS_PER_TEAM' : 'PLRS_>10_PCT', 'AVG_GAMES' : 'GMS_A_M', 'AVG_GOALS_SCORER' : 'GLS_SCOR_M'} ))                      

comp_df_grouped_r = comp_df_grouped.copy()          ### EACH DATAFRAME (DF) THAT WILL BE USED AS A SOURCE FOR CREATING THE FINAL DF: regr_df IS FIRST COPIED. NEW COLUMNS ARE THEN CREATED AND CALCULATED. COLUMN NAMES ARE ALSO RENAMED TO MAINTAIN CONSISTENT NAMING STANDARDS THROUGHOUT THE FILE.
comp_df_grouped_r = (comp_df_grouped_r.assign(
                        GLS_P_LG_M = comp_df_grouped_r['NL_GOALS_SCOR'] / comp_df_grouped_r['NO_OF_GAMES'],
                        GLS_M_LG_M = comp_df_grouped_r['NL_GOALS_LOST'] / comp_df_grouped_r['NO_OF_GAMES'],
                        GMS_LG = comp_df_grouped_r['NO_OF_GAMES'] / comp_df_grouped_r['NO_OF_TEAMS'] * 2)
                        .astype({'NL_GOALS_SCOR' : 'float', 'NL_GOALS_LOST' : 'float', 'NL_GOALS_DIFF' : 'float', 'GOALS_GAME' : 'float', 
                                 'BIG_WIN_SH' : 'float', 'WIN_SH' : 'float', 'GLS_P_LG_M' : 'float', 'GLS_M_LG_M' : 'float'})
                        .rename(columns = {'NO_OF_TEAMS' : 'TEAMS', 'NL_GOALS_DIFF' : 'GLS_DIFF_LG_M', 'GOALS_GAME' : 'GLS_GM_LG_M', 'POINTS' : 'PTS_M', 'COACH_T' : 'COACH_M', 'GAMES_T' : 'GMS_LG'}))  

plbf_df_grouped_col = ['COUNTRY_ID', 'COUNTRY', 'AVG_AGE', 'FORE_SH', 'JOIN_YR_M', 'CTR_EXP_YR_M', 'AVG_VALUE']
perf_ctr_grouped_plus_col = ['COUNTRY_ID', 'GLS_PL_M',  'ASTS_M', 'CRDS_Y_M', 'CRDS_R_M', 'PLRS', 'PLRS_>10_PCT', 'ONLY_BENCH_SH', 'MNS_PLD_M', 'MNS_GMS_M', 'GMS_A_M', 'SCORERS_M', 'GLS_SCOR_M']
comp_df_grouped_col = ['COUNTRY_ID', 'TEAMS', 'GMS_LG', 'GLS_P_LG_M', 'GLS_M_LG_M', 'GLS_GM_LG_M', 'GLS_DIFF_LG_M', 'BIG_WIN_SH', 'WIN_SH', 'PTS_M', 'COACH_M']
games_date_supp_ctr_col = ['COUNTRY_ID', 'HM_GMS_M', 'FANS_M', 'SEATS_M', 'FANS_S_M', 'ARENA_PCT_M', 'ATT_CV_M', 'GAME_TIME_LG_M']

regr_df = (plbf_df_grouped_r.loc[:, plbf_df_grouped_col]
            .merge(perf_ctr_grouped_plus_r.loc[:, perf_ctr_grouped_plus_col], on = 'COUNTRY_ID')
            .merge(comp_df_grouped_r.loc[:, comp_df_grouped_col], on = 'COUNTRY_ID')
            .merge(games_date_supp_ctr_df.loc[:, games_date_supp_ctr_col], how = 'left', on = 'COUNTRY_ID'))  ### COLUMNS FOR THE FINAL DF OBJECT, regr_df, ARE FIRST SELECTED, AND THEN FOUR DATAFRAME SOURCES ARE MERGED BASED ON THE CHOSEN COLUMNS.

regr_df['YRS_EXP'] = 2024.5 - regr_df['JOIN_YR_M']
regr_df = regr_df.rename(columns = {'AVG_AGE' : 'AGE_M', 'AVG_VALUE' : 'VALUE_M'})

gms_columns_grdg = ['GAME_ID', 'HOME_TEAM_ID', 'HOME_TEAM', 'AWAY_TEAM_ID', 'AWAY_TEAM', 'COMPETITION']
games_res_df_games = (games_res_df.loc[ (   (games_res_df['HOME_TEAM_ID'].isin(clubs_df.loc[~clubs_df['COUNTRY_ID'].isin(['SWE21', 'NOR23']),'TEAM_ID'].to_list()))  |
                                            (games_res_df['AWAY_TEAM_ID'].isin(clubs_df.loc[~clubs_df['COUNTRY_ID'].isin(['SWE21', 'NOR23']),'TEAM_ID'].to_list()))  ),   
                                            gms_columns_grdg])          ### games_res_df_games IS CREATED FROM games_res_df. THE DF IS FILTERED TO KEEP ONLY CHOSEN COLUMNS AND GAMES WHERE THE HOST AND/OR VISITOR CLUBS ARE LISTED IN clubs_df. GAMES INVOLVING SWEDISH OR NORWEGIAN CLUBS (WHO DID NOT COMPLETE A FULL SEASON WHEN DATA WAS SCRAPED) ARE REMOVED (EXCEPT EUROPEAN CUP GAMES OF SWEDISH OR NORWEGIAN CLUBS AGAINST TEAMS FROM OTHER ANALYZED NATIONS). THIS LEFT 8107 ROWS/GAMES FOR ANALYSIS.
games_res_df_games['COMPETITION'] = games_res_df_games['COMPETITION'].apply(lambda x: 1 if x == 'NL' else (2 if x in ['ECo', 'ELg', 'ECh', 'FIFA Klub-WM', 'UEFA Super Cup'] else 3))

gms_columns_gdsd = ['GAME_ID', 'GAME_TIME', 'SEATS', 'ATT_EST', 'ARENA_PCT', 'ATT_CV']
games_res_df_games = games_res_df_games.merge(games_date_supp_df[gms_columns_gdsd], on = 'GAME_ID', how = 'left')
games_res_df_games = (games_res_df_games.merge(clubs_df[['COUNTRY_ID', 'TEAM_ID']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID', how = 'left')
                      .merge(clubs_df[['COUNTRY_ID', 'TEAM_ID']], left_on = 'AWAY_TEAM_ID', right_on = 'TEAM_ID', how = 'left')
                      .drop(columns = ['TEAM_ID_x', 'TEAM_ID_y'])       ### THE PREVIOUSLY STRUCTURED DF OBJECT IS FIRST MERGED WITH games_date_supp_df, LIMITED TO CHOSEN COLUMNS, TO ADD DATA ON STADIUM CAPACITY AND MORE. THE PARAMETER how = 'left' IS USED AS TO NOT EXCLUDE GAMES FROM UKRAINE, GREECE, AND BULGARIA THAT WERE REMOVED FROM games_date_supp_df. THEN, TWO MERGE OPERATIONS ARE PERFORMED TO ADD THE COUNTRIES OF THE HOST AND VISITOR CLUBS. THE SOURCE FOR THIS MERGE IS clubs_df TO AVOID HAVING 'UEFA' AS THE COUNTRY_ID.
                      .rename(columns = {'COUNTRY_ID_x' : 'HM_COUNTRY_ID', 'COUNTRY_ID_y' : 'AW_COUNTRY_ID'}))

home_gms = (games_res_df_games.groupby(['HM_COUNTRY_ID', 'HOME_TEAM_ID', 'HOME_TEAM']).
        agg(HM_GMS = ('GAME_ID', 'count'), SEATS = ('SEATS', 'max'), FANS_S = ('ATT_EST', 'sum'), FANS_M = ('ATT_EST', 'mean'), 
            ARENA_PCT_M = ('ARENA_PCT', 'mean'), ATT_CV_M = ('ATT_CV', 'mean')).reset_index())
away_gms = games_res_df_games.groupby(['AWAY_TEAM_ID']).agg(AW_GMS = ('GAME_ID', 'count')).reset_index()

gms_tm_lv_df = home_gms.merge(away_gms, left_on = 'HOME_TEAM_ID', right_on = 'AWAY_TEAM_ID', how = 'inner').drop(columns  = ['AWAY_TEAM_ID'])
gms_tm_lv_df['GMS_A'] = gms_tm_lv_df['HM_GMS'] + gms_tm_lv_df['AW_GMS']   ### THE DF OBJECT IS FIRST GROUPED BY TEAM ID, TEAM NAME, AND TEAM COUNTRY TO KEEP COUNTRY INFORMATION AND FILTER OUT CLUBS NOT PRESENT IN clubs_df AS A BONUS. SEVERAL ATTENDANCE-RELATED METRICS AT THE TEAM LEVEL ARE CALCULATED. A SIMILAR APPROACH IS APPLIED TO COUNT AWAY GAMES, AND THE TWO DFS ARE THEN MERGED USING how = 'inner' TO ONLY KEEP CLUBS PRESENT IN clubs_df FOR FUTURE ANALYSIS.

perf_gms_calc = perf_df.groupby(['TEAM_ID'])['IN_TEAM'].max().reset_index().rename(columns = {'IN_TEAM' : 'GMS_P', 'TEAM_ID' : 'HOME_TEAM_ID'}) 
gms_tm_lv_df = gms_tm_lv_df.merge(perf_gms_calc, on = 'HOME_TEAM_ID')
gms_tm_lv_df['GMS_A'] = gms_tm_lv_df.apply(lambda x : x['GMS_A'] if x['GMS_A'] > x['GMS_P'] else x['GMS_P'], axis = 1)
gms_tm_lv_df = gms_tm_lv_df.drop(columns = ['GMS_P'])       ### perf_gms_calc DF USES groupby TO EXTRACT THE MAXIMUM NUMBER OF GAMES A PLAYER WAS PART OF FOR EACH TEAM (IN_TEAM COLUMN) FROM perf_df. THIS DATA IS MERGED WITH gms_tm_lv_df AND COMPARED TO THE TOTAL NUMBER OF GAMES FROM games_res_df. THE HIGHER NUMBER IS KEPT FOR EACH TEAM, AS THIS APPROACH IS USED DUE TO MISSING DATA ON TRANSFERMARKT. THOUGH perf_df IS ALSO INCOMPLETE DATA SOURCE, COMBINING BOTH APPROACHES IMPROVES DATA ACCURACY.

league_games_times = games_res_df_games[games_res_df_games['COMPETITION'] == 1].groupby('HOME_TEAM_ID')['GAME_TIME'].mean().reset_index()
gms_tm_lv_df = gms_tm_lv_df.merge(league_games_times, on = 'HOME_TEAM_ID')   ### A NEW COLUMN WITH THE AVERAGE LEAGUE GAME START TIME PER TEAM WAS ADDED TO THE DF. THIS CAUSED THE REMOVAL OF 7 ROWS FROM SWEDISH AND NORWEGIAN TEAMS THAT PLAYED IN EURO CUPS, AS THEY LACKED LEAGUE GAME DATA, RESULTING IN THEIR REMOVAL FROM THE DF.

home_gms_comp = games_res_df_games.pivot_table(index = 'HOME_TEAM_ID', columns = 'COMPETITION', values = 'GAME_ID', aggfunc = 'count', fill_value=0).reset_index().rename_axis(None, axis = 1).rename(columns = {1 : 'HM_1', 2 : 'HM_2', 3 : 'HM_3'})
away_gms_comp = games_res_df_games.pivot_table(index = 'AWAY_TEAM_ID', columns = 'COMPETITION', values = 'GAME_ID', aggfunc = 'count', fill_value=0).reset_index().rename_axis(None, axis = 1).rename(columns = {1 : 'AW_1', 2 : 'AW_2', 3 : 'AW_3'})
gms_comp_type = home_gms_comp.merge(away_gms_comp, left_on = 'HOME_TEAM_ID', right_on = 'AWAY_TEAM_ID')
gms_comp_type = gms_comp_type.assign(C_1 = gms_comp_type['HM_1'] + gms_comp_type['AW_1'], C_2 = gms_comp_type['HM_2'] + gms_comp_type['AW_2'], C_3 = gms_comp_type['HM_3'] + gms_comp_type['AW_3'])
gms_tm_lv_df = gms_tm_lv_df.merge(gms_comp_type[['HOME_TEAM_ID', 'C_1', 'C_2', 'C_3']], on = 'HOME_TEAM_ID')
gms_tm_lv_df['GMS_DIFF'] = abs(gms_tm_lv_df['GMS_A'] - (gms_tm_lv_df['C_1'] + gms_tm_lv_df['C_2'] + gms_tm_lv_df['C_3']) )   ### A FUNCTION OF pivot_table WAS APPLIED TO CREATE COLUMNS WITH THE TOTAL NUMBER OF GAMES IN THE NATIONAL LEAGUE, CUP, AND UEFA CUPS PER TEAM. FIRST, THESE NUMBERS WERE CALCULATED SEPARATELY FOR HOME AND AWAY GAMES, THEN SUMMED UP FOR EACH TEAM WITHOUT HOME/AWAY DISTINCTION AND ADDED TO THE FINAL DF.

gms_tm_lv_df = gms_tm_lv_df.merge(clubs_df[['TEAM_ID', 'AVG_AGE', 'AVG_VALUE']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID').drop(columns = ['TEAM_ID'])
gms_tm_lv_df = gms_tm_lv_df.merge(clubs_det_df[['TEAM_ID', 'IN_LEAGUE_SINCE', 'FOREIGNERS_SH']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID').drop(columns = ['TEAM_ID'])   ### ADDING MORE COLUMNS TO THE FINAL DF WITH DATA ON THE TEAM LEVEL. 4 COLUMNS WERE ADDED FROM clubs_df AND clubs_det_df, INCLUDING THE AVERAGE AGE AND VALUE OF PLAYERS, THE NUMBER OF YEARS THE TEAM HAS PLAYED IN THE TOP LEAGUE, AND THE PERCENTAGE OF FOREIGN PLAYERS IN THE TEAM.

clubs_players_calcs_df = players_form_df.copy()
clubs_players_calcs_df['JOINED_YEAR'] = clubs_players_calcs_df[['JOINED_YEAR']].astype(float)   ### THERE ARE 242 PLAYERS MISSING DATA ABOUT THE YEAR THEY JOINED THEIR CURRENT CLUB. TWO CLUBS, EACH MISSING THIS INFORMATION FOR 9 PLAYERS, HAVE DATA ON 25 AND 26 PLAYERS RESPECTIVELY. AS A RESULT, PLAYERS WITHOUT JOINING YEAR DATA WILL BE ASSIGNED THE AVERAGE JOINING YEAR OF THEIR CLUB AS A VALUE IN THIS FIELD.
clubs_players_calcs_df.loc[clubs_players_calcs_df['JOINED_YEAR'] == -1, 'JOINED_YEAR'] = clubs_players_calcs_df.loc[clubs_players_calcs_df['JOINED_YEAR'] == -1, 'TEAM_ID'].map(clubs_players_calcs_df[clubs_players_calcs_df['JOINED_YEAR'] != -1].groupby('TEAM_ID')['JOINED_YEAR'].mean())
clubs_players_calcs_df['CTR_EXP_YEAR_EST'] = clubs_players_calcs_df['TEAM_ID'].map(clubs_players_calcs_df[clubs_players_calcs_df['CONTRACT_EXPIRY_YEAR'] != -1].groupby('TEAM_ID')['CONTRACT_EXPIRY_YEAR'].mean())
clubs_players_calcs_df['CTR_EXP_YR_EST'] = clubs_players_calcs_df.apply(lambda x : x['CONTRACT_EXPIRY_YEAR'] if x['CONTRACT_EXPIRY_YEAR'] != -1 else x['CTR_EXP_YEAR_EST'], axis = 1)  ### TWO NEW COLUMNS WERE CREATED. THE FIRST, USING THE map FUNCTION, RECEIVED THE AVERAGE CONTRACT EXPIRY YEAR FOR EACH TEAM (BASED ONLY ON PLAYERS WHO HAVE THIS DATA). IN THE SECOND COLUMN, THE CONTRACT EXPIRY YEAR WAS ENTERED IF AVAILABLE; OTHERWISE, THE AVERAGE TEAM VALUE FROM THE RECENTLY CREATED COLUMN WAS USED.
clubs_plrs_df = clubs_players_calcs_df.groupby('TEAM_ID').agg(JOIN_YR_M = ('JOINED_YEAR', 'mean'), CTR_EXP_YR_M = ('CTR_EXP_YR_EST', 'mean')).reset_index()
tms_miss_ctr_data = clubs_players_calcs_df[clubs_players_calcs_df['CONTRACT_EXPIRY_YEAR'] == -1].groupby('TEAM_ID')['PLAYER_ID'].count().reset_index().rename(columns = {'PLAYER_ID' : 'MISS_CTR_DATA'})
tms_not_miss_ctr_data = clubs_players_calcs_df[clubs_players_calcs_df['CONTRACT_EXPIRY_YEAR'] != -1].groupby('TEAM_ID')['PLAYER_ID'].count().reset_index().rename(columns = {'PLAYER_ID' : 'WITH_CTR_DATA'})
clubs_plrs_df = clubs_plrs_df.merge(tms_not_miss_ctr_data, on = 'TEAM_ID', how = 'left').fillna(0).merge(tms_miss_ctr_data, on = 'TEAM_ID', how = 'left').fillna(0)
clubs_plrs_df['CTR_DATA_MISS_PCT'] = 100 * clubs_plrs_df['MISS_CTR_DATA'] / (clubs_plrs_df['MISS_CTR_DATA'] + clubs_plrs_df['WITH_CTR_DATA'])   ### USING CALCULATIONS (MAINLY THE groupby FUNCTION) AND A SERIES OF MERGES, A DF OBJECT WAS CREATED. IT CONTAINS TEAM-LEVEL DATA, INCLUDING COLUMNS FOR THE AVERAGE YEAR A PLAYER JOINED THE TEAM, CONTRACT EXPIRATION YEAR, AND THE NUMBER OF PLAYERS WITH AND WITHOUT CONTRACT EXPIRATION YEARS FOR EACH TEAM.
clubs_plrs_df = clubs_plrs_df.merge(clubs_df[['TEAM_ID', 'COUNTRY_ID', 'TEAM']], on = 'TEAM_ID').merge(regr_df[['COUNTRY_ID', 'CTR_EXP_YR_M']].rename(columns = {'CTR_EXP_YR_M' : 'CTR_EXP_YR_CNT_AVG'}), on = 'COUNTRY_ID')

### A CHECK REVEALED 11 TEAMS MISSING CONTRACT EXPIRATION DATA FOR HALF OR MORE OF THEIR PLAYERS. THE BIGGEST ISSUE IS MFK KARVINA (13276), WITH DATA FOR ONLY 2 PLAYERS (BOTH ENDING CONTRACTS IN 2024) AND MISSING IT FOR 28. AS A RESULT, THE TEAM'S AVERAGE CONTRACT EXPIRATION YEAR IS 2024.0, WHILE THE CZECH REPUBLIC'S AVERAGE IS 2025.08. IN CONTRAST, BOHEMIANS PRAGUE 1905 (715) HAS DATA FOR 22 PLAYERS, MISSING IT FOR 9, WITH A TEAM AVERAGE OF 2024.45. THIS SHOWS THERE'S NO POINT/JUSTIFICATION ADJUSTING MFK KARVINA'S AVERAGE TO THE COUNTRY'S AVERAGE.
### GERMANY'S SC FREIBURG (60) HAS CONTRACT EXPIRATION DATA FOR 9 PLAYERS AND IS MISSING IT FOR 19. THE TEAM'S AVERAGE CONTRACT EXPIRATION YEAR IS 2025.11 (WHILE THE AVERAGE FOR GER04 IS 2025.71). IT MUST BE HIGHLIGHTED THAT SV DARMSTADT 98 (105) HAS CONTRACT DATA FOR ALL PLAYERS, WITH AN AVERAGE EXPIRATION YEAR OF 2024.8. EXAMPLES LIKE DARMSTADT 98 AND BOHEMIANS PRAGUE 1905 SHOW THAT THERE IS NO LOGICAL REASON (NOR ANY CLEAR INSTRUCTION) TO MANIPULATE THE AVERAGE CONTRACT EXPIRATION YEAR FOR TEAMS MISSING DATA FOR MOST OF THEIR SQUAD.

gms_tm_lv_df = gms_tm_lv_df.merge(clubs_plrs_df[['TEAM_ID', 'JOIN_YR_M', 'CTR_EXP_YR_M']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID').drop(columns = 'TEAM_ID')
gms_tm_lv_df = gms_tm_lv_df.merge(no_of_coach_df[['TEAM_ID', 'NO_OF_COACH']], left_on = 'HOME_TEAM_ID', right_on = 'TEAM_ID').drop(columns = 'TEAM_ID')   ### SELECTED COLUMNS FROM TWO MORE DFs ARE MERGED AND ADDED TO THE gms_tm_lv_df OBJECT. LATER, COLUMN NAMES ARE CHANGED TO MATCH THE NAMING STANDARDS USED IN THE regr_df TABLE.
gms_tm_lv_df = gms_tm_lv_df.rename(columns = {'HM_COUNTRY_ID' : 'COUNTRY_ID', 'HOME_TEAM_ID' : 'TEAM_ID', 'HOME_TEAM' : 'TEAM', 'AVG_AGE' : 'AGE_M', 'AVG_VALUE' : 'VALUE_M', 'FOREIGNERS_SH' : 'FORE_SH', 'GAME_TIME' : 'GAME_TIME_LG_M', 'NO_OF_COACH' : 'COACH'})

plrs_teams_perf = perf_ctr_df.copy()
plrs_teams_perf = plrs_teams_perf.groupby(['COUNTRY_ID', 'TEAM_ID']).agg(GOALS = ('GOALS', 'sum'), ASSISTS = ('ASSISTS', 'sum'), CRDS_Y = ('YELLOW_CARDS', 'sum'), CRDS_R = ('RED_CARDS', 'sum'), SCORERS = ('SCORED_FLG', 'sum'), PLAYED_PLRS = ('PLAYED_FLG', 'sum'), PROT_PLRS = ('PLAYER_ID', 'count'), PLRS_10_PCT = ('TIME_PLAYED_10_PCT_FLG', 'sum'), TIME_PLAYED = ('TIME_PLAYED', 'sum')).reset_index().rename(columns = {'PLRS_10_PCT' : 'PLRS_>10_PCT'})
plrs_teams_perf['ONLY_BENCH_SH'] = 100 * (plrs_teams_perf['PROT_PLRS'] - plrs_teams_perf['PLAYED_PLRS']) / plrs_teams_perf['PROT_PLRS']   ### ANOTHER PREVIOUSLY CREATED DATAFRAME IS USED AS A DATA SOURCE, GROUPED BY TEAM LEVEL, AND SOME METRICS ARE CALCULATED. INTERESTINGLY, groupby DOESN'T ALLOW THE USE OF '>' IN COLUMN NAMES. TO MAINTAIN DOCUMENT NAMING STANDARDS, THE '>' SIGN WAS LATER ADDED USING THE rename FUNCTION.

goals_2nd_src = games_team_df.merge(games_res_df[['GAME_ID', '>90_FLG']], on = 'GAME_ID')
goals_2nd_src = goals_2nd_src[goals_2nd_src['>90_FLG'] == 0].groupby('TEAM_ID')['GOALS_SCORED'].sum().reset_index()
plrs_teams_perf = plrs_teams_perf.merge(goals_2nd_src, on = 'TEAM_ID')
plrs_teams_perf = plrs_teams_perf.assign(GOALS = lambda x : np.where(x['GOALS'] > x['GOALS_SCORED'], x['GOALS'], x['GOALS_SCORED']))
plrs_teams_perf['GLS_SCOR_M'] = plrs_teams_perf['GOALS'] / plrs_teams_perf['SCORERS']
plrs_teams_perf['MNS_PLD_M'] = plrs_teams_perf['TIME_PLAYED'] / plrs_teams_perf['PLAYED_PLRS']
plrs_teams_perf = plrs_teams_perf.drop(columns = ['GOALS_SCORED', 'COUNTRY_ID', 'PROT_PLRS']).rename(columns = {'PLAYED_PLRS' : 'PLRS'})  ### THE PREVIOUS APPROACH OF CHOOSING THE HIGHER NUMBER OF RECORDED GAMES FROM perf_df OR games_res_df WAS REPEATED HERE TO SELECT THE HIGHER NUMBER OF GOALS SCORED BY A TEAM. THE DATAFRAMES ARE MERGED TO EXCLUDE GOALS FROM GAMES THAT ENDED IN EXTRA TIME OR PENALTIES. THEN, THE lambda AND np.where FUNCTIONS ARE USED TO SELECT THE HIGHER OF THE TWO GOAL TOTALS FOR EACH TEAM. ADDITIONAL METRICS ARE CALCULATED, AND UNNECESSARY COLUMNS ARE REMOVED.

gms_tm_lv_df = gms_tm_lv_df.merge(plrs_teams_perf, on = 'TEAM_ID')
gms_tm_lv_df = (gms_tm_lv_df.assign( GLS_PL_M = lambda x : x['GOALS'] / x['GMS_A'], ASTS_M = lambda x : x['ASSISTS'] / x['GMS_A'], CRDS_Y_M = lambda x : x['CRDS_Y'] / x['GMS_A'],
                                    CRDS_R_M = lambda x : x['CRDS_R'] / x['GMS_A'], MNS_GMS_M = lambda x : x['MNS_PLD_M'] / x['GMS_A'])
                            .drop(columns = ['GOALS', 'ASSISTS', 'CRDS_Y', 'CRDS_R']))      ### MERGING THE PREVIOUSLY CREATED DF INTO THE MAIN DF. NEW COLUMNS ARE CREATED TO PRESENT AVERAGE METRICS FOR GOALS AND CARDS PER GAME FOR EACH ANALYZED TEAM. UNNECESSARY COLUMNS ARE THEN REMOVED.

league_games_df_columns = ['GAME_ID', 'COUNTRY_ID', 'HOME_FLG', 'TEAM_ID', 'TEAM', 'OPPONENT_ID', 'OPPONENT', 'COMPETITION', 'GOALS_SCORED', 'GOALS_LOST', 'POINTS']
home_league_games_df = games_team_df.loc[ ((games_team_df['COMPETITION'] == 'NL') & (games_team_df['HOME_FLG'] == 1)), league_games_df_columns ].copy()
away_league_games_df = games_team_df.loc[((games_team_df['COMPETITION'] == 'NL') & (games_team_df['HOME_FLG'] == 0)), league_games_df_columns ].copy()
hm_gms_not_listed_as_aw_gms_df = home_league_games_df[~home_league_games_df['GAME_ID'].isin(away_league_games_df['GAME_ID'].to_list())]
aw_gms_not_listed_as_hm_gms_df = away_league_games_df[~away_league_games_df['GAME_ID'].isin(home_league_games_df['GAME_ID'].to_list())]  ### TWO DF OBJECTS WITH ONLY LEAGUE GAMES WERE CREATED: ONE FROM THE HOME TEAM PERSPECTIVE AND ANOTHER FROM THE AWAY TEAM PERSPECTIVE. IN games_team_df, EACH GAME_ID SHOULD APPEAR TWICE (ONCE FOR HOME TEAM, ONCE FOR AWAY TEAM). HOWEVER, AS PREVIOUSLY MENTIONED, games_team_df DOES NOT FULLY CAPTURE EVERY GAME DUE TO ISSUES WITH TRANSFERMARKT PAGE. TO FIX THIS, GAMES RECORDED FROM THE HOME TEAM PERSPECTIVE BUT MISSING FROM THE AWAY TEAM DF WERE IDENTIFIED (AND VICE VERSA).

away_league_games_df_rotated = aw_gms_not_listed_as_hm_gms_df.assign(
                GAME_ID = aw_gms_not_listed_as_hm_gms_df['GAME_ID'], COUNTRY_ID = aw_gms_not_listed_as_hm_gms_df['COUNTRY_ID'], HOME_FLG = 1,TEAM_ID = aw_gms_not_listed_as_hm_gms_df['OPPONENT_ID'], 
                TEAM = aw_gms_not_listed_as_hm_gms_df['OPPONENT'], OPPONENT_ID = aw_gms_not_listed_as_hm_gms_df['TEAM_ID'], OPPONENT = aw_gms_not_listed_as_hm_gms_df['TEAM'], COMPETITION = aw_gms_not_listed_as_hm_gms_df['COMPETITION'],
                GOALS_SCORED = aw_gms_not_listed_as_hm_gms_df['GOALS_LOST'], GOALS_LOST = aw_gms_not_listed_as_hm_gms_df['GOALS_SCORED'], POINTS = aw_gms_not_listed_as_hm_gms_df['POINTS'].
                apply(lambda x : 3 if x == 0 else ( 1 if x == 1 else 0)) )      ### GAMES RECORDED ONLY FROM THE HOME TEAM PERSPECTIVE ARE LESS OF A PROBLEM NOW. TO AVOID MISSING GAMES RECORDED ONLY FROM THE AWAY TEAM PERSPECTIVE, THESE CASES WERE IDENTIFIED (9 EXAMPLES). THEN, THE DF WITH 9 ROWS WAS REVERSED: HOME_FLG WAS SET TO 1, TEAM_ID WAS SWAPPED WITH THE OPPONENT_ID, GOALS_SCORED SWITCHED WITH GOALS_LOST, ETC. THIS WAY, THESE 9 ROWS ARE NOW SHOWN FROM THE HOME TEAM PERSPECTIVE AND WILL BE CONCATENATED TO THE ORIGINAL DF.

league_games_home_df = pd.concat([home_league_games_df, away_league_games_df_rotated])
league_games_home_df = league_games_home_df[~league_games_home_df['COUNTRY_ID'].isin(['SWE21', 'NOR23'])]
league_games_home_df['GOALS_DIFF'] = abs(league_games_home_df['GOALS_SCORED'] - league_games_home_df['GOALS_LOST'])   ### ORIGINALLY SCRAPED HOME GAMES AND THE 9 REVERSED AWAY GAMES (NOT PRESENT ORIGINALLY FROM THE HOME TEAM PERSPECTIVE) ARE CONCATENATED INTO ONE DF. GAMES FROM NORWAY AND SWEDEN ARE THEN EXCLUDED, AND A NEW COLUMN FOR THE ABSOLUTE GOAL DIFFERENCE IS CREATED.

league_games_away_df = league_games_home_df.copy()
league_games_away_df = league_games_away_df.assign(HOME_FLG = 0, TEAM_ID = league_games_away_df['OPPONENT_ID'], TEAM = league_games_away_df['OPPONENT'], OPPONENT_ID = league_games_away_df['TEAM_ID'], OPPONENT = league_games_away_df['TEAM'],
                                                   GOALS_SCORED = league_games_away_df['GOALS_LOST'], GOALS_LOST = league_games_away_df['GOALS_SCORED'],
                                                   POINTS = league_games_away_df['POINTS'].apply(lambda x : 3 if x == 0 else ( 1 if x == 1 else 0)) )  ###  THE DATABASE WITH LEAGUE GAMES PRESENTED FROM THE HOME TEAM PERSPECTIVE (INCLUDING THE 9 REVERSED MISSING GAMES FROM THE AWAY PERSPECTIVE) IS NOW REVERSED. HOME_FLG IS CHANGED TO 0, TEAM_ID IS SWAPPED WITH OPPONENT_ID, GOALS_SCORED WITH GOALS_LOST, AND POINTS ARE RECALCULATED.

leag_gms_compl_df = pd.concat([league_games_home_df, league_games_away_df])
leag_gms_compl_df = leag_gms_compl_df.assign(WIN = lambda x : np.where(x['GOALS_SCORED'] > x['GOALS_LOST'], 1, 0), BIG_WIN = lambda x : np.where(x['GOALS_SCORED'] - x['GOALS_LOST'] >= 3, 1, 0))
leag_gms_compl_ctr_df = leag_gms_compl_df.groupby(['COUNTRY_ID', 'TEAM_ID', 'TEAM']).agg(GMS_LG = ('GAME_ID', 'count'), GLS_P_LG_M = ('GOALS_SCORED', 'mean'), GLS_M_LG_M = ('GOALS_LOST', 'mean'), GLS_DIFF_LG_M = ('GOALS_DIFF', 'mean'), PTS_M = ('POINTS', 'mean'), BIG_WIN_SH = ('BIG_WIN', 'sum'), WIN_SH = ('WIN', 'sum')).reset_index()
leag_gms_compl_ctr_df = leag_gms_compl_ctr_df.assign(GLS_GM_LG_M = lambda x : x['GLS_P_LG_M'] + x['GLS_M_LG_M'], BIG_WIN_SH = lambda x : 100 * x['BIG_WIN_SH'] / x['GMS_LG'], WIN_SH = lambda x : 100 * x['WIN_SH'] / x['GMS_LG'])
leag_gms_compl_ctr_df.drop(columns = ['COUNTRY_ID', 'TEAM'], inplace = True) ### FIRST, DFs WITH GAMES FROM THE HOME AND AWAY TEAM PERSPECTIVES ARE CONCATENATED. THEN, FLAGS TO FILTER WON GAMES AND GAMES WON WITH A 3+ GOAL ADVANTAGE ARE CREATED. NEXT, THE DF IS GROUPED BY COUNTRY_ID AND TEAM_ID, WITH SEVERAL COLUMNS CALCULATED AS MEAN OR SUM VALUES. FINALLY, UNUSED COLUMNS ARE DELETED.

gms_tm_lv_df = gms_tm_lv_df.merge(leag_gms_compl_ctr_df, on = 'TEAM_ID')

dfs_to_export = {'plbf_df_grouped' : plbf_df_grouped, 'perf_ctr_grouped_plus' : perf_ctr_grouped_plus, 'comp_df_grouped' : comp_df_grouped, 'games_date_supp_ctr_df' : games_date_supp_ctr_df, 'regr_df' : regr_df, 'gms_tm_lv_df' : gms_tm_lv_df, 'perf_ctr_df' : perf_ctr_df, 'comp_df_league_gr_pt' : comp_df_league_gr_pt, 'games_date_supp_df' : games_date_supp_df, 'games_team_df' : games_team_df, 'games_res_df' : games_res_df, 'players_bio_df' : players_bio_df, 'players_form_df' : players_form_df, 'players_ni_df' : players_ni_df, 'clubs_df' : clubs_df, 'perf_df' : perf_df, 'leagues_df' : leagues_df}
for df_name, df_object in dfs_to_export.items():
    df_object.to_pickle('C:/XXX/' + df_name + '.pkl')   ### THE DICTIONARY WITH THE NAMES OF THE DATAFRAMES TO EXPORT WAS PREPARED. LATER, USING A FOR LOOP, EACH DATAFRAME IN THE DICTIONARY WILL BE EXPORTED USING THE to_pickle FUNCTION, ALLOWING FOR LATER USE OF THE EDITED DATAFRAME OBJECTS IN THE DATA VISUALIZATION FILE.
    
    
    
